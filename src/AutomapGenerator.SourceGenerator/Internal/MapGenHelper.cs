using System.Diagnostics.CodeAnalysis;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;

namespace AutomapGenerator.SourceGenerator.Internal;

internal static class MapGenHelper {
    private const string INDENT = "    ";
    private const string MAP_METHOD_NAME = "Map";
    private const string PROJECTTO_METHOD_NAME = "ProjectTo";
    private const string GENERIC_TYPE_NAME_DESTINATION = "TDestination";
    private const string MAPPER_INTERFACE = "IMapper";
    private const string MAP_INTERNAL_METHOD_NAME = "MapInternal";
    private static readonly string _generatorVersion = typeof(MapperGenerator).Assembly.GetName().Version.ToString();

    public static NamespaceDeclarationSyntax CreateMapperClass(MapDefinition[] sources) {
        var mapExistingMethods = CreateMapExistingMethods(INDENT + INDENT, sources);
        var mapNewMethod = CreateMapNewMethod(mapExistingMethods, sources, INDENT + INDENT);
        var projectMethods = CreateProjectToMethods(INDENT + INDENT, sources);

        var mapperMethods = new List<MemberDeclarationSyntax> {
            mapNewMethod.WithTrailingTrivia(CarriageReturnLineFeed, CarriageReturnLineFeed)
        };

        for (var i = 0; i < mapExistingMethods.Count; i++) {
            mapperMethods.Add(mapExistingMethods[i].WithTrailingTrivia(CarriageReturnLineFeed, CarriageReturnLineFeed));
        }
        for (var i = 0; i < projectMethods.Count; i++) {
            if (i == projectMethods.Count - 1) {
                // Don't add trailing trivia to the last method
                mapperMethods.Add(projectMethods[i]);
            } else {
                mapperMethods.Add(projectMethods[i].WithTrailingTrivia(CarriageReturnLineFeed, CarriageReturnLineFeed));
            }
        }

        return CreateCoreNamespace()
        .WithMembers(
            SingletonList<MemberDeclarationSyntax>(
                //ClassDeclaration("Mapper")
                ClassDeclaration(Identifier(
                    TriviaList(Space),
                    "Mapper",
                    TriviaList(Space)))
                .WithAutoGeneratedCodeAttributes(INDENT, withCodeCoverageExclusion: true)
                .WithModifiers(
                    TokenList(Token(
                        TriviaList(Whitespace(INDENT)),
                        SyntaxKind.PublicKeyword,
                        TriviaList(Space))))
                .WithBaseList(
                    BaseList(
                        SingletonSeparatedList<BaseTypeSyntax>(
                            SimpleBaseType(IdentifierName(MAPPER_INTERFACE))
                                .WithLeadingTrivia(Space))))
                .WithOpenBraceToken(Token(
                    TriviaList(CarriageReturnLineFeed, Whitespace(INDENT)),
                    SyntaxKind.OpenBraceToken,
                    TriviaList(CarriageReturnLineFeed)))
                .WithCloseBraceToken(Token(
                    TriviaList(CarriageReturnLineFeed, Whitespace(INDENT)),
                    SyntaxKind.CloseBraceToken,
                    TriviaList()))
                .WithMembers(List(mapperMethods))));
    }

    private static MethodDeclarationSyntax CreateMapNewSignature(string sourceParamName, string indentation)
        => MethodDeclaration(
            IdentifierName(GENERIC_TYPE_NAME_DESTINATION),
            Identifier(TriviaList(Space), MAP_METHOD_NAME, TriviaList()))
        .WithTypeParameterList(
            TypeParameterList(
                SingletonSeparatedList(
                    TypeParameter(Identifier(GENERIC_TYPE_NAME_DESTINATION)))))
        .WithParameterList(
            ParameterList(
                SingletonSeparatedList(
                    Parameter(
                        Identifier(sourceParamName))
                    .WithType(PredefinedType(Token(
                        TriviaList(),
                        SyntaxKind.ObjectKeyword,
                        TriviaList(Space))))))
            .WithTrailingTrivia(CarriageReturnLineFeed));

    private static MethodDeclarationSyntax CreateMapExistingSignature(string sourceParamName, string destinationParamName)
        => MethodDeclaration(
            IdentifierName(GENERIC_TYPE_NAME_DESTINATION),
            Identifier(
                TriviaList(Space),
                MAP_METHOD_NAME,
                TriviaList()))
        .WithTypeParameterList(
            TypeParameterList(
                SingletonSeparatedList(
                    TypeParameter(
                        Identifier(GENERIC_TYPE_NAME_DESTINATION)))))
        .WithParameterList(
            ParameterList(
                SeparatedList<ParameterSyntax>(new SyntaxNodeOrToken[] {
                    Parameter(Identifier(TriviaList(Space), sourceParamName, TriviaList())).WithType(PredefinedType(Token(SyntaxKind.ObjectKeyword))),
                    Token(TriviaList(), SyntaxKind.CommaToken, TriviaList(Space)),
                    Parameter(Identifier(TriviaList(Space), destinationParamName, TriviaList())).WithType(IdentifierName(GENERIC_TYPE_NAME_DESTINATION))
                })));

    private static MethodDeclarationSyntax CreateProjectToSignature(string sourceParamName, string indentation)
        => MethodDeclaration(
                AliasQualifiedName(
                    IdentifierName(Token(SyntaxKind.GlobalKeyword)),
                    GenericName(Identifier(typeof(IQueryable).FullName))
                    .WithTypeArgumentList(TypeArgumentList(
                        SingletonSeparatedList<TypeSyntax>(IdentifierName(GENERIC_TYPE_NAME_DESTINATION))
                    ))
                    .WithTrailingTrivia(Space)
                ),
                Identifier(PROJECTTO_METHOD_NAME))
        .WithTypeParameterList(TypeParameterList(
            SingletonSeparatedList(
                TypeParameter(Identifier(GENERIC_TYPE_NAME_DESTINATION))
            )))
        .WithParameterList(ParameterList(
            SingletonSeparatedList(
                Parameter(Identifier(
                    TriviaList(Space),
                    sourceParamName,
                    TriviaList()))
                .WithType(
                    AliasQualifiedName(
                        IdentifierName(Token(SyntaxKind.GlobalKeyword)),
                        GenericName(Identifier(typeof(IQueryable).FullName))
                        .WithTypeArgumentList(TypeArgumentList(
                            SingletonSeparatedList<TypeSyntax>(PredefinedType(Token(SyntaxKind.ObjectKeyword)))
                        ))
                    ))
            )));

    private static NamespaceDeclarationSyntax CreateCoreNamespace()
        => NamespaceDeclaration(
            //IdentifierName(typeof(MappingException).Namespace)) // TODO: This currently does not work in consuming project. Need to investigate why
            IdentifierName("AutomapGenerator"))
        .WithNamespaceKeyword(
            Token(
                TriviaList(Comment("// <auto-generated/>"), CarriageReturnLineFeed),
                SyntaxKind.NamespaceKeyword,
                TriviaList(Space)))
        .WithOpenBraceToken(
            Token(
                TriviaList(CarriageReturnLineFeed),
                SyntaxKind.OpenBraceToken,
                TriviaList(CarriageReturnLineFeed)))
        .WithCloseBraceToken(
            Token(
                TriviaList(CarriageReturnLineFeed),
                SyntaxKind.CloseBraceToken,
                TriviaList(CarriageReturnLineFeed)));

    private static MethodDeclarationSyntax CreateMapNewMethod(List<MethodDeclarationSyntax> mapExistingMethods, MapDefinition[] sources, string indentation) {
        var sourceVarName = "source";
        var switchSections = new List<SwitchSectionSyntax>();
        for (var i = 0; i < mapExistingMethods.Count; i++) {
            var method = mapExistingMethods[i];
            if (method.Identifier.Text == MAP_METHOD_NAME) {
                continue; // This is not one of the internal map methods, so skip it
            }

            switchSections.Add(CreateMapNewSwitchSection(method, sources, sourceVarName, indentation));
        }

        var needsStringMap = false;
        for (var i = 0; i < sources.Length; i++) {
            for (var j = 0; j < sources[i].Mappings.Count; j++) {
                if (sources[i].Mappings[j].DestinationSymbol.SpecialType == SpecialType.System_String) {
                    needsStringMap = true;
                    break;
                }
            }
            if (needsStringMap) {
                break;
            }
        }
        if (needsStringMap) {
            switchSections.Insert(0, CreateMapNewStringSwitchSection(sourceVarName, indentation));
        }

        switchSections.Add(CreateDefaultSwitchThrow(sourceVarName, true, indentation + INDENT + INDENT));

        return CreateMapNewSignature(sourceVarName, indentation)
            .WithModifiers(
                TokenList(Token(
                    TriviaList(Whitespace(indentation)),
                    SyntaxKind.PublicKeyword,
                    TriviaList(Space))))
            .WithBody(Block(
                SingletonList<StatementSyntax>(
                    SwitchStatement(
                        TupleExpression(SeparatedList<ArgumentSyntax>(new SyntaxNodeOrToken[] {
                            Argument(IdentifierName(sourceVarName)),
                            Token(TriviaList(), SyntaxKind.CommaToken, TriviaList(Space)),
                            Argument(TypeOfExpression(IdentifierName(GENERIC_TYPE_NAME_DESTINATION)))
                        })))
                    .WithSwitchKeyword(Token(
                        TriviaList(Whitespace(indentation + INDENT)),
                        SyntaxKind.SwitchKeyword,
                        TriviaList(Space)))
                    .WithSections(List(switchSections))
                    .WithOpenBraceToken(Token(
                        TriviaList(CarriageReturnLineFeed, Whitespace(indentation + INDENT)),
                        SyntaxKind.OpenBraceToken,
                        TriviaList(CarriageReturnLineFeed)))
                    .WithCloseBraceToken(Token(
                        TriviaList(CarriageReturnLineFeed, Whitespace(indentation + INDENT)),
                        SyntaxKind.CloseBraceToken,
                        TriviaList()))))
            .WithOpenBraceToken(Token(
                TriviaList(Whitespace(indentation)),
                SyntaxKind.OpenBraceToken,
                TriviaList(CarriageReturnLineFeed)))
            .WithCloseBraceToken(Token(
                TriviaList(CarriageReturnLineFeed, Whitespace(indentation)),
                SyntaxKind.CloseBraceToken,
                TriviaList())));

    }

    private static MapDefinition.Mapping GetMappingFromSourceToDestination(MapDefinition[] sources, TypeSyntax sourceType, TypeSyntax destinationType) {
        var sourceName = sourceType.ToString();
        var destinationName = destinationType.ToString();

        for (var i = 0; i < sources.Length; i++) {
            var definition = sources[i];
            if (definition.MappingsBySource.TryGetValue(sourceName, out var mappings)) {
                for (var j = 0; j < mappings.Count; j++) {
                    var mapping = mappings[j];
                    if (mapping.DestinationName == destinationName) {
                        return mapping;
                    }
                }
            }
        }
        // It shouldn't be possible to get here!
        throw new Exception("No mapping from the given source to destination found");
    }

    private static bool TryGetObjectCreationExpressionFrom(MapDefinition.Mapping mapping, [NotNullWhen(true)] out ObjectCreationExpressionSyntax? objectCreationExpression) {
        for (var i = 0; i < mapping.DestinationConstructors.Length; i++) {
            var ctor = mapping.DestinationConstructors[i];
            if (ctor.Parameters.Length == 0) {
                objectCreationExpression = ObjectCreationExpression(
                    ParseTypeName(mapping.DestinationName)
                    .WithLeadingTrivia(Space))
                .WithArgumentList(ArgumentList());
                return true;
            }
        }

        objectCreationExpression = null;
        return false;
    }

    private static ReturnStatementSyntax ReturnFromMapInternal(ArgumentSyntax sourceArg, ArgumentSyntax destinationArg)
        => ReturnStatement(
            CastExpression(
                IdentifierName("dynamic"),
                InvocationExpression(IdentifierName(MAP_INTERNAL_METHOD_NAME))
                .WithArgumentList(ArgumentList(SeparatedList<ArgumentSyntax>(new SyntaxNodeOrToken[] {
                    sourceArg,
                    Token(
                        TriviaList(),
                        SyntaxKind.CommaToken,
                        TriviaList(Space)),
                    destinationArg
                }))))
            .WithLeadingTrivia(Space));

    private static SwitchSectionSyntax CreateMapNewStringSwitchSection(string sourceVarName, string indentation) {
        var typeMatchVarName = "t";

        return SwitchSection()
            .WithLabels(SingletonList<SwitchLabelSyntax>(
                CasePatternSwitchLabel(
                    RecursivePattern()
                    .WithPositionalPatternClause(
                        PositionalPatternClause(SeparatedList<SubpatternSyntax>(new SyntaxNodeOrToken[] {
                            Subpattern(
                                DiscardPattern()),
                            Token(
                                TriviaList(),
                                SyntaxKind.CommaToken,
                                TriviaList(Space)),
                            Subpattern(
                                DeclarationPattern(
                                    ParseTypeName("System.Type"),
                                    SingleVariableDesignation(Identifier(
                                        TriviaList(Space),
                                        typeMatchVarName,
                                        TriviaList()))))
                        }))
                        .WithLeadingTrivia(Space)
                        .WithTrailingTrivia(Space)),
                    Token(
                        TriviaList(),
                        SyntaxKind.ColonToken,
                        TriviaList(CarriageReturnLineFeed)))
                .WithWhenClause(
                    WhenClause(
                        BinaryExpression(
                            SyntaxKind.EqualsExpression,
                            IdentifierName(Identifier(
                                TriviaList(Space),
                                typeMatchVarName,
                                TriviaList(Space))),
                            TypeOfExpression(PredefinedType(Token(SyntaxKind.StringKeyword)))
                                .WithLeadingTrivia(Space))))
                .WithLeadingTrivia(Whitespace(indentation + INDENT + INDENT))))
            .WithStatements(
                SingletonList<StatementSyntax>(
                    ReturnMapToString(sourceVarName)
                    .WithLeadingTrivia(Whitespace(indentation + INDENT + INDENT + INDENT))
                    .WithTrailingTrivia(CarriageReturnLineFeed)));
    }

    private static SwitchSectionSyntax CreateMapNewSwitchSection(MethodDeclarationSyntax mapInternalMethod, MapDefinition[] sources, string sourceVarName, string indentation) {
        var sourceType = mapInternalMethod.ParameterList.Parameters[0].Type!;
        var destinationType = mapInternalMethod.ParameterList.Parameters[1].Type!;
        var mapping = GetMappingFromSourceToDestination(sources, sourceType, destinationType);

        var typeMatchVarName = "t";
        var sourceMatchVarName = "s";

        var switchStatement = TryGetObjectCreationExpressionFrom(mapping, out var objCreationExpr)
            ? ReturnFromMapInternal(Argument(IdentifierName(sourceMatchVarName)), Argument(objCreationExpr))
            : (StatementSyntax)CreateConstructorMapException(sourceVarName);

        return SwitchSection()
            .WithLabels(SingletonList<SwitchLabelSyntax>(
                CasePatternSwitchLabel(
                    RecursivePattern()
                    .WithPositionalPatternClause(
                        PositionalPatternClause(SeparatedList<SubpatternSyntax>(new SyntaxNodeOrToken[] {
                            Subpattern(
                                DeclarationPattern(
                                    sourceType,
                                    SingleVariableDesignation(Identifier(
                                        TriviaList(Space),
                                        sourceMatchVarName,
                                        TriviaList())))),
                            Token(
                                TriviaList(),
                                SyntaxKind.CommaToken,
                                TriviaList(Space)),
                            Subpattern(
                                DeclarationPattern(
                                    ParseTypeName("System.Type"),
                                    SingleVariableDesignation(Identifier(
                                        TriviaList(Space),
                                        typeMatchVarName,
                                        TriviaList()))))
                        }))
                        .WithLeadingTrivia(Space)
                        .WithTrailingTrivia(Space)),
                    Token(
                        TriviaList(),
                        SyntaxKind.ColonToken,
                        TriviaList(CarriageReturnLineFeed)))
                .WithWhenClause(
                    WhenClause(
                        BinaryExpression(
                            SyntaxKind.EqualsExpression,
                            IdentifierName(Identifier(
                                TriviaList(Space),
                                typeMatchVarName,
                                TriviaList(Space))),
                            TypeOfExpression(destinationType)
                                .WithLeadingTrivia(Space))))
                .WithLeadingTrivia(Whitespace(indentation + INDENT + INDENT))))
            .WithStatements(
                SingletonList(
                    switchStatement
                    .WithLeadingTrivia(Whitespace(indentation + INDENT + INDENT + INDENT))
                    .WithTrailingTrivia(CarriageReturnLineFeed)));
    }

    private static List<MethodDeclarationSyntax> CreateMapExistingMethods(string indentation, MapDefinition[] srcMappings) {
        var destinationVarName = "destination";
        var sourceVarName = "source";

        var internalMapMethods = new List<MethodDeclarationSyntax>();
        var switchSections = new List<SwitchSectionSyntax>();
        var needsStringMap = false;
        for (var i = 0; i < srcMappings.Length; i++) {
            var definition = srcMappings[i];
            for (var j = 0; j < definition.Mappings.Count; j++) {
                var mapping = definition.Mappings[j];
                if (!mapping.ProjectionOnly) {
                    if (mapping.DestinationSymbol.SpecialType == SpecialType.System_String) {
                        needsStringMap = true;
                    } else {
                        var mapMethod = CreateInternalMapMethod(definition, mapping, indentation);
                        internalMapMethods.Add(mapMethod);
                        switchSections.Add(CreateMapMethodSwitchSection(mapMethod, indentation + INDENT + INDENT));
                    }
                }
            }
        }

        if (needsStringMap) {
            switchSections.Insert(0, CreateMapToStringSwitchSection(sourceVarName, indentation + INDENT + INDENT));
        }

        // Add the default switch section 
        switchSections.Add(CreateDefaultSwitchThrow(sourceVarName, false, indentation + INDENT + INDENT));

        // Add the public method at the beginning
        internalMapMethods.Insert(0,
            CreateMapExistingSignature(sourceVarName, destinationVarName)
                .WithModifiers(
                    TokenList(
                        Token(
                            TriviaList(Whitespace(indentation)),
                            SyntaxKind.PublicKeyword,
                            TriviaList(Space))))
                .WithBody(
                    Block(
                        SwitchStatement(
                            TupleExpression(
                                SeparatedList<ArgumentSyntax>(new SyntaxNodeOrToken[] {
                                        Argument(IdentifierName(sourceVarName)),
                                        Token(TriviaList(), SyntaxKind.CommaToken, TriviaList(Space)),
                                        Argument(IdentifierName(destinationVarName))
                                }))
                            .WithLeadingTrivia(Space))
                        .WithLeadingTrivia(Whitespace(indentation + INDENT))
                        .WithOpenBraceToken(Token(
                            TriviaList(CarriageReturnLineFeed, Whitespace(indentation + INDENT)),
                            SyntaxKind.OpenBraceToken,
                            TriviaList(CarriageReturnLineFeed)))
                        .WithSections(List(switchSections))
                        .WithCloseBraceToken(Token(
                            TriviaList(CarriageReturnLineFeed, Whitespace(indentation + INDENT)),
                            SyntaxKind.CloseBraceToken,
                            TriviaList()))
                    )
                    .WithOpenBraceToken(Token(
                        TriviaList(CarriageReturnLineFeed, Whitespace(indentation)),
                        SyntaxKind.OpenBraceToken,
                        TriviaList(CarriageReturnLineFeed)))
                    .WithCloseBraceToken(Token(
                        TriviaList(CarriageReturnLineFeed, Whitespace(indentation)),
                        SyntaxKind.CloseBraceToken,
                        TriviaList())))
        );
        return internalMapMethods;
    }

    private static List<MethodDeclarationSyntax> CreateProjectToMethods(string indentation, MapDefinition[] srcMappings) {
        var sourceVarName = "source";

        var internalProjectMethods = new List<MethodDeclarationSyntax>();
        var switchSections = new List<SwitchSectionSyntax>();
        var projectedSources = new List<string>();

        for (var i = 0; i < srcMappings.Length; i++) {
            var definition = srcMappings[i];
            var sources = definition.MappingsBySource.Keys.ToList();
            for (var j = 0; j < sources.Count; j++) {
                var source = sources[j];
                if (projectedSources.Contains(source)) {
                    continue;
                }
                projectedSources.Add(source);

                var projectMethod = CreateInternalProjectMethod(srcMappings, source, indentation);
                internalProjectMethods.Add(projectMethod);
                switchSections.Add(CreateProjectToMethodSwitchSection(projectMethod, indentation + INDENT + INDENT));
            }
        }

        // Add the default switch section
        switchSections.Add(CreateDefaultSwitchThrow(sourceVarName, true, indentation + INDENT + INDENT));

        // Add the public method at the beginning
        internalProjectMethods.Insert(0,
            CreateProjectToSignature(sourceVarName, indentation)
                .WithModifiers(
                    TokenList(Token(
                        TriviaList(Whitespace(indentation)),
                        SyntaxKind.PublicKeyword,
                        TriviaList(Space))))
                .WithBody(
                    Block(
                        SwitchStatement(IdentifierName(sourceVarName))
                        .WithSwitchKeyword(Token(
                            TriviaList(),
                            SyntaxKind.SwitchKeyword,
                            TriviaList(Space)))
                        .WithLeadingTrivia(Whitespace(indentation + INDENT))
                        .WithOpenBraceToken(Token(
                            TriviaList(CarriageReturnLineFeed, Whitespace(indentation + INDENT)),
                            SyntaxKind.OpenBraceToken,
                            TriviaList(CarriageReturnLineFeed)))
                        .WithSections(List(switchSections))
                        .WithCloseBraceToken(Token(
                            TriviaList(CarriageReturnLineFeed, Whitespace(indentation + INDENT)),
                            SyntaxKind.CloseBraceToken,
                            TriviaList()))
                    )
                    .WithOpenBraceToken(Token(
                        TriviaList(CarriageReturnLineFeed, Whitespace(indentation)),
                        SyntaxKind.OpenBraceToken,
                        TriviaList(CarriageReturnLineFeed)))
                    .WithCloseBraceToken(Token(
                        TriviaList(CarriageReturnLineFeed, Whitespace(indentation)),
                        SyntaxKind.CloseBraceToken,
                        TriviaList())))
        );
        return internalProjectMethods;
    }

    private static MethodDeclarationSyntax CreateInternalMapMethod(MapDefinition definition, MapDefinition.Mapping mapping, string indentation) {
        var patternMatchSrcName = ParseTypeName(mapping.SourceName);
        var patternMatchDestName = ParseTypeName(mapping.DestinationName);
        var matchedSrcVarName = "source";
        var matchedDestVarName = "destination";

        var expressions = new List<StatementSyntax>();
        var destMappings = definition.GetDestinationMappings(mapping, matchedSrcVarName);
        for (var i = 0; i < destMappings.Count; i++) {
            (var destProp, var srcProp) = destMappings[i];

            var srcExpr = ParseExpression(srcProp);

            expressions.Add(ExpressionStatement(
                AssignmentExpression(
                    SyntaxKind.SimpleAssignmentExpression,
                    MemberAccessExpression(
                        SyntaxKind.SimpleMemberAccessExpression,
                        IdentifierName(matchedDestVarName),
                        IdentifierName(destProp).WithTrailingTrivia(Space)),
                    srcExpr.WithLeadingTrivia(Space)))
                .WithLeadingTrivia(Whitespace(indentation + INDENT))
                .WithTrailingTrivia(CarriageReturnLineFeed));
        }

        expressions.Add(
            ReturnStatement(IdentifierName(
                Identifier(
                    TriviaList(Space),
                    matchedDestVarName,
                    TriviaList())))
            .WithLeadingTrivia(CarriageReturnLineFeed, Whitespace(indentation + INDENT))
            .WithTrailingTrivia(CarriageReturnLineFeed));

        return MethodDeclaration(
            patternMatchDestName,
            Identifier(
                TriviaList(Space),
                MAP_INTERNAL_METHOD_NAME,
                TriviaList())
        ).WithModifiers(TokenList(
            Token(
                TriviaList(Whitespace(indentation)),
                SyntaxKind.PrivateKeyword,
                TriviaList(Space))
        )).WithParameterList(ParameterList(SeparatedList<ParameterSyntax>(new SyntaxNodeOrToken[] {
            Parameter(Identifier(TriviaList(Space), matchedSrcVarName, TriviaList())).WithType(patternMatchSrcName),
            Token(TriviaList(), SyntaxKind.CommaToken, TriviaList(Space)),
            Parameter(Identifier(TriviaList(Space), matchedDestVarName, TriviaList())).WithType(patternMatchDestName)
        })))
        .WithBody(
            Block(expressions)
            .WithOpenBraceToken(Token(
                TriviaList(CarriageReturnLineFeed, Whitespace(indentation)),
                SyntaxKind.OpenBraceToken,
                TriviaList(CarriageReturnLineFeed)))
            .WithCloseBraceToken(Token(
                TriviaList(Whitespace(indentation)),
                SyntaxKind.CloseBraceToken,
                TriviaList())));
    }

    private static ReturnStatementSyntax ReturnMapToString(string sourceVarName)
        => ReturnStatement(
            CastExpression(
                IdentifierName("dynamic"),
                PostfixUnaryExpression(
                    SyntaxKind.SuppressNullableWarningExpression,
                    ConditionalAccessExpression(
                        IdentifierName(sourceVarName),
                        InvocationExpression(
                            MemberBindingExpression(
                                IdentifierName("ToString"))))))
            .WithLeadingTrivia(Space));

    private static SwitchSectionSyntax CreateMapToStringSwitchSection(string sourceVarName, string indentation) {
        var matchedDestVarName = "d";

        return SwitchSection()
            .WithLabels(
                SingletonList<SwitchLabelSyntax>(
                    CasePatternSwitchLabel(
                        RecursivePattern()
                        .WithPositionalPatternClause(
                            PositionalPatternClause(
                                SeparatedList<SubpatternSyntax>(new SyntaxNodeOrToken[] {
                                    Subpattern(
                                        DiscardPattern()),
                                    Token(
                                        TriviaList(),
                                        SyntaxKind.CommaToken,
                                        TriviaList(Space)),
                                    Subpattern(
                                        DeclarationPattern(
                                            PredefinedType(Token(SyntaxKind.StringKeyword)),
                                            SingleVariableDesignation(Identifier(
                                                TriviaList(Space),
                                                matchedDestVarName,
                                                TriviaList()))))
                                }))
                            .WithLeadingTrivia(Space)),
                        Token(SyntaxKind.ColonToken))))
            .WithLeadingTrivia(Whitespace(indentation))
            .WithTrailingTrivia(CarriageReturn)
            .WithStatements(SingletonList<StatementSyntax>(
                ReturnMapToString(sourceVarName)
                .WithLeadingTrivia(Whitespace(indentation + INDENT))
                .WithTrailingTrivia(CarriageReturnLineFeed)
            ));
    }

    private static SwitchSectionSyntax CreateMapMethodSwitchSection(MethodDeclarationSyntax mapMethod, string indentation) {
        var patternMatchSrcName = mapMethod.ParameterList.Parameters[0].Type!;
        var patternMatchDestName = mapMethod.ParameterList.Parameters[1].Type!;
        var matchedSrcVarName = "s";
        var matchedDestVarName = "d";

        return SwitchSection()
            .WithLabels(
                SingletonList<SwitchLabelSyntax>(
                    CasePatternSwitchLabel(
                        RecursivePattern()
                        .WithPositionalPatternClause(
                            PositionalPatternClause(
                                SeparatedList<SubpatternSyntax>(new SyntaxNodeOrToken[] {
                                    Subpattern(
                                        DeclarationPattern(
                                            patternMatchSrcName,
                                            SingleVariableDesignation(Identifier(
                                                TriviaList(Space),
                                                matchedSrcVarName,
                                                TriviaList())))),
                                    Token(
                                        TriviaList(),
                                        SyntaxKind.CommaToken,
                                        TriviaList(Space)),
                                    Subpattern(
                                        DeclarationPattern(
                                            patternMatchDestName,
                                            SingleVariableDesignation(Identifier(
                                                TriviaList(Space),
                                                matchedDestVarName,
                                                TriviaList()))))
                                }))
                            .WithLeadingTrivia(Space)),
                        Token(SyntaxKind.ColonToken))))
            .WithLeadingTrivia(Whitespace(indentation))
            .WithTrailingTrivia(CarriageReturn)
            .WithStatements(SingletonList<StatementSyntax>(
                ReturnFromMapInternal(
                    Argument(IdentifierName(matchedSrcVarName)), 
                    Argument(IdentifierName(matchedDestVarName)))
                .WithLeadingTrivia(Whitespace(indentation + INDENT))
                .WithTrailingTrivia(CarriageReturnLineFeed)
            ));
    }

    private static InvocationExpressionSyntax CreateLinqSelectExpression(string sourceVarName, string lambdaVarName, SimpleLambdaExpressionSyntax linqSelectLambdaExpression)
        => InvocationExpression(
            MemberAccessExpression(
                SyntaxKind.SimpleMemberAccessExpression,
                MemberAccessExpression(
                    SyntaxKind.SimpleMemberAccessExpression,
                    AliasQualifiedName(
                        IdentifierName(Token(SyntaxKind.GlobalKeyword)),
                        IdentifierName(typeof(Queryable).Namespace)),
                    IdentifierName(nameof(Queryable))),
                IdentifierName(Identifier(nameof(Queryable.Select)))))
        .WithArgumentList(ArgumentList(SeparatedList<ArgumentSyntax>(new SyntaxNodeOrToken[] {
            Argument(IdentifierName(sourceVarName)),
            Token(
                TriviaList(),
                SyntaxKind.CommaToken,
                TriviaList(Space)),
            Argument(linqSelectLambdaExpression)
        })));

    private static MethodDeclarationSyntax CreateInternalProjectMethod(MapDefinition[] definitions, string sourceName, string indentation) {
        var patternMatchSrcName = WrapTypeInIQueryable(ParseTypeName(sourceName));
        var matchedSrcVarName = "sourceQueryable";
        var lambdaVarName = "source";
        var typeMatchVarName = "t";

        var switchSections = new List<SwitchSectionSyntax>();
        for (var i = 0; i < definitions.Length; i++) {
            var definition = definitions[i];
            if (!definition.MappingsBySource.TryGetValue(sourceName, out var mappings)) {
                continue;
            }
            for (var j = 0; j < mappings.Count; j++) {
                var mapping = mappings[j];
                var patternMatchDestName = ParseTypeName(mapping.DestinationName);
                StatementSyntax switchStatement;
                if (TryCreateProjectToString(mapping, lambdaVarName, out var selectLambda)
                    || TryCreateProjectionObjectInitializer(definition, mapping, lambdaVarName, indentation + INDENT + INDENT + INDENT, out selectLambda)) {
                    var linqSelect = CreateLinqSelectExpression(matchedSrcVarName, lambdaVarName, selectLambda);

                    var linqCast = InvocationExpression(
                            MemberAccessExpression(
                                SyntaxKind.SimpleMemberAccessExpression,
                                MemberAccessExpression(
                                    SyntaxKind.SimpleMemberAccessExpression,
                                    AliasQualifiedName(
                                        IdentifierName(Token(SyntaxKind.GlobalKeyword)),
                                        IdentifierName(typeof(Queryable).Namespace)),
                                    IdentifierName(nameof(Queryable))),
                                GenericName(Identifier(nameof(Queryable.Cast)))
                                .WithTypeArgumentList(TypeArgumentList(
                                    SingletonSeparatedList<TypeSyntax>(
                                        IdentifierName(GENERIC_TYPE_NAME_DESTINATION))))))
                        .WithArgumentList(ArgumentList(SingletonSeparatedList(
                            Argument(linqSelect)
                            .WithLeadingTrivia(CarriageReturnLineFeed, Whitespace(indentation + INDENT + INDENT + INDENT + INDENT)))))
                        .WithLeadingTrivia(Space);

                    switchStatement = ReturnStatement(linqCast);
                } else {
                    switchStatement = CreateConstructorMapException(matchedSrcVarName);
                }

                var switchSection = SwitchSection()
                    .WithLabels(SingletonList<SwitchLabelSyntax>(
                        CasePatternSwitchLabel(
                            DeclarationPattern(
                                ParseTypeName("System.Type").WithLeadingTrivia(Space),
                                SingleVariableDesignation(Identifier(
                                    TriviaList(Space),
                                    typeMatchVarName,
                                    TriviaList(Space)))),
                            Token(
                                TriviaList(),
                                SyntaxKind.ColonToken,
                                TriviaList(CarriageReturnLineFeed)))
                        .WithLeadingTrivia(Whitespace(indentation + INDENT + INDENT))
                        .WithWhenClause(WhenClause(
                            BinaryExpression(
                                SyntaxKind.EqualsExpression,
                                IdentifierName(Identifier(
                                    TriviaList(Space),
                                    typeMatchVarName,
                                    TriviaList(Space))),
                                TypeOfExpression(patternMatchDestName).WithLeadingTrivia(Space))))))
                    .WithStatements(SingletonList(
                        switchStatement
                        .WithLeadingTrivia(Whitespace(indentation + INDENT + INDENT + INDENT))
                        .WithTrailingTrivia(CarriageReturnLineFeed)));

                switchSections.Add(switchSection);
            }
        }

        switchSections.Add(CreateDefaultSwitchThrow(matchedSrcVarName, true, indentation + INDENT + INDENT));

        return MethodDeclaration(
            WrapTypeInIQueryable(IdentifierName(GENERIC_TYPE_NAME_DESTINATION)),
            Identifier(
                TriviaList(Space),
                "ProjectInternal",
                TriviaList())
        ).WithModifiers(TokenList(
            Token(
                TriviaList(Whitespace(indentation)),
                SyntaxKind.PrivateKeyword,
                TriviaList(Space))
        )).WithTypeParameterList(TypeParameterList(SingletonSeparatedList(
            TypeParameter(GENERIC_TYPE_NAME_DESTINATION)
        ))).WithParameterList(ParameterList(SingletonSeparatedList(
            Parameter(Identifier(TriviaList(Space), matchedSrcVarName, TriviaList())).WithType(patternMatchSrcName)
        )))
        .WithBody(
            Block(SingletonList<StatementSyntax>(
                SwitchStatement(
                    TypeOfExpression(IdentifierName(GENERIC_TYPE_NAME_DESTINATION)))
                .WithSwitchKeyword(Token(
                    TriviaList(Whitespace(indentation + INDENT)),
                    SyntaxKind.SwitchKeyword,
                    TriviaList(Space)))
                .WithSections(List(switchSections))
                .WithOpenBraceToken(Token(
                    TriviaList(CarriageReturnLineFeed, Whitespace(indentation + INDENT)),
                    SyntaxKind.OpenBraceToken,
                    TriviaList(CarriageReturnLineFeed)))
                .WithCloseBraceToken(Token(
                    TriviaList(CarriageReturnLineFeed, Whitespace(indentation + INDENT)),
                    SyntaxKind.CloseBraceToken,
                    TriviaList(CarriageReturnLineFeed)))
            )).WithOpenBraceToken(Token(
                TriviaList(CarriageReturnLineFeed, Whitespace(indentation)),
                SyntaxKind.OpenBraceToken,
                TriviaList(CarriageReturnLineFeed)))
            .WithCloseBraceToken(Token(
                TriviaList(Whitespace(indentation)),
                SyntaxKind.CloseBraceToken,
                TriviaList())));
    }

    private static bool TryCreateProjectToString(MapDefinition.Mapping mapping, string lambdaVarName, [NotNullWhen(true)] out SimpleLambdaExpressionSyntax? toStringExpression) {
        if (mapping.DestinationSymbol.SpecialType != SpecialType.System_String) {
            toStringExpression = null;
            return false;
        }

        if (mapping.SourceSymbol.IsReferenceType) {
            var nullLiteral = LiteralExpression(SyntaxKind.NullLiteralExpression)
                .WithLeadingTrivia(Space)
                .WithTrailingTrivia(Space);

            toStringExpression = SimpleLambdaExpression(
                Parameter(Identifier(
                    TriviaList(),
                    lambdaVarName,
                    TriviaList(Space))))
                .WithExpressionBody(
                    ConditionalExpression(
                        BinaryExpression(
                            SyntaxKind.EqualsExpression,
                            IdentifierName(Identifier(
                                TriviaList(),
                                lambdaVarName,
                                TriviaList(Space))),
                            nullLiteral),
                        nullLiteral,
                        InvocationExpression(
                            MemberAccessExpression(
                                SyntaxKind.SimpleMemberAccessExpression,
                                IdentifierName(lambdaVarName),
                                IdentifierName("ToString")))
                        .WithLeadingTrivia(Space))
                    .WithLeadingTrivia(Space));
        } else {
            toStringExpression = SimpleLambdaExpression(
                Parameter(Identifier(
                    TriviaList(),
                    lambdaVarName,
                    TriviaList(Space))))
                .WithExpressionBody(
                    InvocationExpression(
                        MemberAccessExpression(
                            SyntaxKind.SimpleMemberAccessExpression,
                            IdentifierName(lambdaVarName),
                            IdentifierName("ToString")))
                    .WithLeadingTrivia(Space));
        }
        return true;
    }

    private static bool TryCreateProjectionObjectInitializer(MapDefinition definition, MapDefinition.Mapping mapping, string lambdaVarName, string indentation, [NotNullWhen(true)] out SimpleLambdaExpressionSyntax? objectCreationLambdaExpression) {
        for (var i = 0; i < mapping.DestinationConstructors.Length; i++) {
            var ctor = mapping.DestinationConstructors[i];
            if (ctor.Parameters.Length > 0) {
                continue; // For now, we only support parameterless constructors
            }

            var patternMatchDestName = ParseTypeName(mapping.DestinationName);
            var expressions = new List<SyntaxNodeOrToken>();
            var destMappings = definition.GetDestinationMappings(mapping, lambdaVarName);
            for (var j = 0; j < destMappings.Count; j++) {
                (var destProp, var srcProp) = destMappings[j];

                // Add a comma after the last expression before adding another
                if (expressions.Count > 0) {
                    expressions.Add(Token(
                        TriviaList(),
                        SyntaxKind.CommaToken,
                        TriviaList(CarriageReturnLineFeed)));
                }

                var srcNullableParts = srcProp.Split(new[] { "?." }, StringSplitOptions.None);
                var expressionRight = BuildLinqExpressionWithNullChecks(srcNullableParts);

                expressions.Add(
                    AssignmentExpression(
                        SyntaxKind.SimpleAssignmentExpression,
                        IdentifierName(destProp)
                            .WithLeadingTrivia(Whitespace(indentation + INDENT + INDENT))
                            .WithTrailingTrivia(Space),
                        expressionRight.WithLeadingTrivia(Space)));
            }

            var objectCreationExpression = ObjectCreationExpression(patternMatchDestName)
                .WithNewKeyword(Token(
                    TriviaList(Space),
                    SyntaxKind.NewKeyword,
                    TriviaList(Space)))
                .WithArgumentList(ArgumentList());

            if (expressions.Count > 0) {
                objectCreationExpression = objectCreationExpression
                    .WithInitializer(
                        InitializerExpression(
                            SyntaxKind.ObjectInitializerExpression,
                            SeparatedList<ExpressionSyntax>(expressions))
                        .WithOpenBraceToken(Token(
                            TriviaList(CarriageReturnLineFeed, Whitespace(indentation + INDENT)),
                            SyntaxKind.OpenBraceToken,
                            TriviaList(CarriageReturnLineFeed)))
                        .WithCloseBraceToken(Token(
                            TriviaList(CarriageReturnLineFeed, Whitespace(indentation + INDENT)),
                            SyntaxKind.CloseBraceToken,
                            TriviaList())));
            }

            objectCreationLambdaExpression = SimpleLambdaExpression(
                Parameter(Identifier(
                    TriviaList(),
                    lambdaVarName,
                    TriviaList(Space))))
                .WithExpressionBody(objectCreationExpression);

            return true;
        }

        objectCreationLambdaExpression = null;
        return false;
    }

    private static TypeSyntax WrapTypeInIQueryable(TypeSyntax innerType)
        => QualifiedName(
            AliasQualifiedName(
                IdentifierName(Token(SyntaxKind.GlobalKeyword)),
                IdentifierName(typeof(IQueryable).Namespace)),
            GenericName(nameof(IQueryable))
                .WithTypeArgumentList(TypeArgumentList(
                    SingletonSeparatedList(innerType))));

    private static SwitchSectionSyntax CreateProjectToMethodSwitchSection(MethodDeclarationSyntax projectMethod, string indentation) {
        var sourceType = projectMethod.ParameterList.Parameters[0].Type!;
        var matchedSrcVarName = "s";

        return SwitchSection()
            .WithLabels(
                SingletonList<SwitchLabelSyntax>(
                    CasePatternSwitchLabel(
                        DeclarationPattern(
                            sourceType,
                            SingleVariableDesignation(Identifier(
                                TriviaList(Space),
                                matchedSrcVarName,
                                TriviaList())))
                        .WithLeadingTrivia(Space),
                        Token(SyntaxKind.ColonToken))
                    .WithLeadingTrivia(Whitespace(indentation))
                    .WithTrailingTrivia(CarriageReturnLineFeed)))
            .WithStatements(
                SingletonList<StatementSyntax>(
                    ReturnStatement(
                        InvocationExpression(
                            GenericName(projectMethod.Identifier.Text)
                            .WithTypeArgumentList(TypeArgumentList(
                                SingletonSeparatedList<TypeSyntax>(
                                    IdentifierName(GENERIC_TYPE_NAME_DESTINATION)))))
                        .WithArgumentList(ArgumentList(SingletonSeparatedList(
                            Argument(IdentifierName(matchedSrcVarName)))))
                        .WithLeadingTrivia(Space))
                    .WithLeadingTrivia(Whitespace(indentation + INDENT))
                    .WithTrailingTrivia(CarriageReturnLineFeed)));
    }

    private static ExpressionSyntax BuildLinqExpressionWithNullChecks(string[] nullableParts) {
        var memberExpr = ParseExpression(string.Join(".", nullableParts));

        if (nullableParts.Length <= 1) {
            return memberExpr;
        }

        var binaryExpressions = new List<ExpressionSyntax>();

        // Do not consume the last nullable part as it is the final value
        var nullCheckIdentifier = string.Empty;
        for (var i = 0; i < nullableParts.Length - 1; i++) {
            if (nullCheckIdentifier.Length > 0) {
                nullCheckIdentifier += ".";
            }
            nullCheckIdentifier += nullableParts[i];

            binaryExpressions.Add(BinaryExpression(
                SyntaxKind.NotEqualsExpression,
                ParseExpression(nullCheckIdentifier).WithTrailingTrivia(Space),
                LiteralExpression(SyntaxKind.NullLiteralExpression)
                .WithLeadingTrivia(Space)
            ));
        }

        // Process the binary expressions in the reverse order in order to build them up correctly
        ExpressionSyntax condition = null!;
        for (var i = binaryExpressions.Count - 1; i >= 0; i--) {
            condition = condition is null
                ? binaryExpressions[i]
                : BinaryExpression(
                    SyntaxKind.LogicalAndExpression,
                    binaryExpressions[i].WithTrailingTrivia(Space),
                    condition.WithLeadingTrivia(Space)
                );
        }

        return ConditionalExpression(
            condition.WithTrailingTrivia(Space),
            memberExpr.WithLeadingTrivia(Space).WithTrailingTrivia(Space),
            LiteralExpression(SyntaxKind.NullLiteralExpression)
            .WithLeadingTrivia(Space)
        );
    }

    private static SwitchSectionSyntax CreateDefaultSwitchThrow(string sourceVarName, bool isMappingToNew, string indentation)
        => SwitchSection()
        .WithLabels(SingletonList<SwitchLabelSyntax>(
            DefaultSwitchLabel()
                .WithLeadingTrivia(Whitespace(indentation))
                .WithTrailingTrivia(CarriageReturnLineFeed)))
        .WithStatements(SingletonList<StatementSyntax>(
            CreateMappingException(sourceVarName, isMappingToNew, "has not been configured")
            .WithLeadingTrivia(Whitespace(indentation + INDENT))));

    private static ThrowStatementSyntax CreateConstructorMapException(string sourceVarName)
        => CreateMappingException(sourceVarName, true, "does not have a compatible constructor");

    private static ThrowStatementSyntax CreateMappingException(string sourceVarName, bool isMappingToNew, string exceptionReason)
        => ThrowStatement(
        ObjectCreationExpression(
            //IdentifierName(nameof(MappingException))) // TODO: This currently does not work in consuming project. Need to investigate why
            IdentifierName("MappingException")
                .WithLeadingTrivia(Space))
        .WithLeadingTrivia(Space)
        .WithArgumentList(
            ArgumentList(
                SingletonSeparatedList(
                    Argument(
                        InterpolatedStringExpression(
                                Token(SyntaxKind.InterpolatedStringStartToken))
                        .WithContents(List(new InterpolatedStringContentSyntax[] {
                        InterpolatedStringText()
                        .WithTextToken(Token(
                            TriviaList(),
                            SyntaxKind.InterpolatedStringTextToken,
                            "Mapping from ",
                            "Mapping from ",
                            TriviaList())),
                        Interpolation(MemberAccessExpression(
                            SyntaxKind.SimpleMemberAccessExpression,
                            InvocationExpression(
                                MemberAccessExpression(
                                    SyntaxKind.SimpleMemberAccessExpression,
                                    IdentifierName(sourceVarName),
                                    IdentifierName("GetType"))),
                            IdentifierName("Name"))),
                        InterpolatedStringText()
                        .WithTextToken(Token(
                            TriviaList(),
                            SyntaxKind.InterpolatedStringTextToken,
                            $" to {(isMappingToNew ? "new" : "existing")} ",
                            $" to {(isMappingToNew ? "new" : "existing")} ",
                            TriviaList())),
                        Interpolation(
                            MemberAccessExpression(
                                SyntaxKind.SimpleMemberAccessExpression,
                                TypeOfExpression(
                                    IdentifierName(GENERIC_TYPE_NAME_DESTINATION)),
                                IdentifierName("Name"))),
                        InterpolatedStringText()
                        .WithTextToken(Token(
                            TriviaList(),
                            SyntaxKind.InterpolatedStringTextToken,
                            $" {exceptionReason}.",
                            $" {exceptionReason}.",
                            TriviaList()))
                        })))))));

    private static TypeDeclarationSyntax WithAutoGeneratedCodeAttributes(this TypeDeclarationSyntax interfaceDeclaration, string indentation, bool withCodeCoverageExclusion = false) {
        var attributes = new List<AttributeListSyntax> {
            // Generated-Code Attribute
            AttributeList(SingletonSeparatedList(
                Attribute(
                    AliasQualifiedName(
                        IdentifierName(Token(SyntaxKind.GlobalKeyword)),
                        FullAttributeDisplayIdentifier<System.CodeDom.Compiler.GeneratedCodeAttribute>()
                    )
                )
                .WithArgumentList(
                    AttributeArgumentList(SeparatedList<AttributeArgumentSyntax>(new SyntaxNodeOrToken[] {
                        AttributeArgument(
                            LiteralExpression(
                                SyntaxKind.StringLiteralExpression,
                                Literal(typeof(MapperGenerator).FullName))),
                        Token(
                            TriviaList(),
                            SyntaxKind.CommaToken,
                            TriviaList(Space)),
                        AttributeArgument(
                            LiteralExpression(
                                SyntaxKind.StringLiteralExpression,
                                Literal(_generatorVersion)))
                    })))))
            .WithLeadingTrivia(Whitespace(indentation))
            .WithTrailingTrivia(CarriageReturnLineFeed)
        };
        if (withCodeCoverageExclusion) {
            attributes.Add(
                // ExcludeFromCodeCoverage attribute
                AttributeList(SingletonSeparatedList(
                    Attribute(
                        AliasQualifiedName(
                            IdentifierName(Token(SyntaxKind.GlobalKeyword)),
                            FullAttributeDisplayIdentifier<System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverageAttribute>()
                        )
                    )))
                .WithLeadingTrivia(Whitespace(indentation))
                .WithTrailingTrivia(CarriageReturnLineFeed)
            );
        }

        return interfaceDeclaration.WithAttributeLists(List(attributes));
    }

    private static IdentifierNameSyntax FullAttributeDisplayIdentifier<TAttribute>() where TAttribute : Attribute {
        var attrName = typeof(TAttribute).FullName;
        var attrSuffix = "Attribute";
        return IdentifierName(attrName.Substring(0, attrName.Length - attrSuffix.Length));
    }
}
