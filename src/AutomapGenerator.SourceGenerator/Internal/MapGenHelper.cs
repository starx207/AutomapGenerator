using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;

namespace AutomapGenerator.SourceGenerator.Internal;

internal static class MapGenHelper {
    private const string MAP_METHOD_NAME = "Map";
    private const string PROJECTTO_METHOD_NAME = "ProjectTo";
    private const string GENERIC_TYPE_NAME_DESTINATION = "TDestination";
    private const string MAPPER_INTERFACE = "IMapper";
    private static readonly string _generatorVersion = typeof(MapperGenerator).Assembly.GetName().Version.ToString();

    public static NamespaceDeclarationSyntax CreateMapperClass(MapDefinition[] sources) {
        var mapperMethods = new List<MemberDeclarationSyntax> {
            CreateMapNewMethod(),
            CreateMapExistingMethod(sources),
            CreateProjectToMethod(sources)
        };

        return CreateCoreNamespace()
        .WithMembers(
            SingletonList<MemberDeclarationSyntax>(
                ClassDeclaration("Mapper")
                .WithAutoGeneratedCodeAttributes(withCodeCoverageExclusion: true)
                .WithModifiers(
                    TokenList(
                        Token(SyntaxKind.PublicKeyword)))
                .WithBaseList(
                    BaseList(
                        SingletonSeparatedList<BaseTypeSyntax>(
                            SimpleBaseType(IdentifierName(MAPPER_INTERFACE)))))
                .WithMembers(List(mapperMethods))))
        .NormalizeWhitespace();
    }

    private static MethodDeclarationSyntax CreateMapNewSignature(string sourceParamName)
        => MethodDeclaration(
            IdentifierName(GENERIC_TYPE_NAME_DESTINATION),
            Identifier(MAP_METHOD_NAME))
        .WithTypeParameterList(
            TypeParameterList(
                SingletonSeparatedList(
                    TypeParameter(Identifier(GENERIC_TYPE_NAME_DESTINATION)))))
        .WithParameterList(
            ParameterList(
                SingletonSeparatedList(
                    Parameter(
                        Identifier(sourceParamName))
                    .WithType(PredefinedType(Token(SyntaxKind.ObjectKeyword))))))
        .WithConstraintClauses(
            SingletonList(
                TypeParameterConstraintClause(
                    IdentifierName(GENERIC_TYPE_NAME_DESTINATION))
                .WithConstraints(
                    SingletonSeparatedList<TypeParameterConstraintSyntax>(
                        ConstructorConstraint()))));

    private static MethodDeclarationSyntax CreateMapExistingSignature(string sourceParamName, string destinationParamName)
        => MethodDeclaration(
            IdentifierName(GENERIC_TYPE_NAME_DESTINATION),
            Identifier(MAP_METHOD_NAME))
        .WithTypeParameterList(
            TypeParameterList(
                SingletonSeparatedList(
                    TypeParameter(
                        Identifier(GENERIC_TYPE_NAME_DESTINATION)))))
        .WithParameterList(
            ParameterList(
                SeparatedList<ParameterSyntax>(new SyntaxNodeOrToken[] {
                    Parameter(Identifier(sourceParamName)).WithType(PredefinedType(Token(SyntaxKind.ObjectKeyword))),
                    Token(SyntaxKind.CommaToken),
                    Parameter(Identifier(destinationParamName)).WithType(IdentifierName(GENERIC_TYPE_NAME_DESTINATION))
                })));

    private static MethodDeclarationSyntax CreateProjectToSignature(string sourceParamName)
        => MethodDeclaration(
                AliasQualifiedName(
                    IdentifierName(Token(SyntaxKind.GlobalKeyword)),
                    GenericName(Identifier(typeof(IQueryable).FullName))
                    .WithTypeArgumentList(TypeArgumentList(
                        SingletonSeparatedList<TypeSyntax>(IdentifierName(GENERIC_TYPE_NAME_DESTINATION))
                    ))
                ),
                Identifier(PROJECTTO_METHOD_NAME))
        .WithTypeParameterList(TypeParameterList(
            SingletonSeparatedList(
                TypeParameter(Identifier(GENERIC_TYPE_NAME_DESTINATION))
            )))
        .WithParameterList(ParameterList(
            SingletonSeparatedList(
                Parameter(Identifier(sourceParamName))
                .WithType(
                    AliasQualifiedName(
                        IdentifierName(Token(SyntaxKind.GlobalKeyword)),
                        GenericName(Identifier(typeof(IQueryable).FullName))
                        .WithTypeArgumentList(TypeArgumentList(
                            SingletonSeparatedList<TypeSyntax>(PredefinedType(Token(SyntaxKind.ObjectKeyword)))
                        ))
                    ))
            )))
        .WithConstraintClauses(SingletonList(
            TypeParameterConstraintClause(IdentifierName(GENERIC_TYPE_NAME_DESTINATION))
            .WithConstraints(SingletonSeparatedList<TypeParameterConstraintSyntax>(ConstructorConstraint()))
        ));

    private static NamespaceDeclarationSyntax CreateCoreNamespace()
        => NamespaceDeclaration(
            //IdentifierName(typeof(MappingException).Namespace)) // TODO: This currently does not work in consuming project. Need to investigate why
            IdentifierName("AutomapGenerator"))
        .WithNamespaceKeyword(
            Token(
                TriviaList(Comment("// <auto-generated/>")),
                SyntaxKind.NamespaceKeyword,
                TriviaList()));

    private static MethodDeclarationSyntax CreateMapNewMethod() {
        var sourceVarName = "source";

        return CreateMapNewSignature(sourceVarName)
            .WithModifiers(
                TokenList(
                    Token(SyntaxKind.PublicKeyword)))
            .WithExpressionBody(
                ArrowExpressionClause(
                    InvocationExpression(
                        GenericName(
                            Identifier(MAP_METHOD_NAME))
                        .WithTypeArgumentList(
                            TypeArgumentList(
                                SingletonSeparatedList<TypeSyntax>(IdentifierName(GENERIC_TYPE_NAME_DESTINATION)))))
                    .WithArgumentList(
                        ArgumentList(
                            SeparatedList<ArgumentSyntax>(new SyntaxNodeOrToken[] {
                                Argument(IdentifierName(sourceVarName)),
                                Token(SyntaxKind.CommaToken),
                                Argument(
                                    ObjectCreationExpression(IdentifierName(GENERIC_TYPE_NAME_DESTINATION))
                                    .WithArgumentList(ArgumentList()))
                            })))))
            .WithSemicolonToken(Token(SyntaxKind.SemicolonToken));
    }

    private static MethodDeclarationSyntax CreateMapExistingMethod(MapDefinition[] srcMappings) {
        var destinationVarName = "destination";
        var sourceVarName = "source";

        var switchSections = new List<SwitchSectionSyntax>();
        for (var i = 0; i < srcMappings.Length; i++) {
            var definition = srcMappings[i];
            for (var j = 0; j < definition.Mappings.Count; j++) {
                var mapping = definition.Mappings[j];
                if (!mapping.ProjectionOnly) {
                    switchSections.Add(CreateMapMethodSwitchSection(definition, mapping));
                }
            }
        }

        // Add the default switch section 
        switchSections.Add(CreateDefaultSwitchThrow(sourceVarName));

        return CreateMapExistingSignature(sourceVarName, destinationVarName)
            .WithModifiers(
                TokenList(
                    Token(SyntaxKind.PublicKeyword)))
            .WithBody(
                Block(
                    SwitchStatement(
                        TupleExpression(
                            SeparatedList<ArgumentSyntax>(new SyntaxNodeOrToken[] {
                                Argument(IdentifierName(sourceVarName)),
                                Token(SyntaxKind.CommaToken),
                                Argument(IdentifierName(destinationVarName))
                            })))
                    .WithSections(List(switchSections)),
                    ReturnStatement(IdentifierName(destinationVarName))
                ));
    }

    private static MemberDeclarationSyntax CreateProjectToMethod(MapDefinition[] srcMappings) {
        var destinationVarName = "destInstance";
        var sourceVarName = "source";

        var switchSections = new List<SwitchSectionSyntax>();
        for (var i = 0; i < srcMappings.Length; i++) {
            var definition = srcMappings[i];
            for (var j = 0; j < definition.Mappings.Count; j++) {
                var mapping = definition.Mappings[j];
                switchSections.Add(CreateProjectToMethodSwitchSection(definition, mapping));
            }
        }

        // Add the default switch section
        switchSections.Add(CreateDefaultSwitchThrow(sourceVarName));

        return CreateProjectToSignature(sourceVarName)
            .WithModifiers(
                TokenList(
                    Token(SyntaxKind.PublicKeyword)))
            .WithBody(
                Block(
                    LocalDeclarationStatement(
                        VariableDeclaration(
                            IdentifierName(
                                Identifier(
                                    TriviaList(),
                                    SyntaxKind.VarKeyword,
                                    "var",
                                    "var",
                                    TriviaList())))
                        .WithVariables(
                            SingletonSeparatedList(
                                VariableDeclarator(Identifier(destinationVarName))
                                .WithInitializer(
                                    EqualsValueClause(
                                        ObjectCreationExpression(IdentifierName(GENERIC_TYPE_NAME_DESTINATION))
                                        .WithArgumentList(ArgumentList())))))),

                    SwitchStatement(
                        TupleExpression(
                            SeparatedList<ArgumentSyntax>(new SyntaxNodeOrToken[] {
                                Argument(IdentifierName(sourceVarName)),
                                Token(SyntaxKind.CommaToken),
                                Argument(IdentifierName(destinationVarName))
                            })))
                    .WithSections(List(switchSections))
                ));
    }

    private static SwitchSectionSyntax CreateMapMethodSwitchSection(MapDefinition definition, MapDefinition.Mapping mapping) {
        var patternMatchSrcName = ParseTypeName(mapping.SourceName);
        var patternMatchDestName = ParseTypeName(mapping.DestinationName);
        var matchedSrcVarName = "s";
        var matchedDestVarName = "d";

        var expressions = new List<StatementSyntax>();
        var destMappings = definition.GetDestinationMappings(mapping);
        for (var i = 0; i < destMappings.Count; i++) {
            (var destProp, var srcProp) = destMappings[i];

            expressions.Add(ExpressionStatement(
                AssignmentExpression(
                    SyntaxKind.SimpleAssignmentExpression,
                    MemberAccessExpression(
                        SyntaxKind.SimpleMemberAccessExpression,
                        IdentifierName(matchedDestVarName),
                        IdentifierName(destProp)),
                    MemberAccessExpression(
                        SyntaxKind.SimpleMemberAccessExpression,
                        IdentifierName(matchedSrcVarName),
                        IdentifierName(srcProp)))));
        }
        expressions.Add(BreakStatement());

        return SwitchSection()
            .WithLabels(
                SingletonList<SwitchLabelSyntax>(
                    CasePatternSwitchLabel(
                        RecursivePattern()
                        .WithPositionalPatternClause(
                            PositionalPatternClause(
                                SeparatedList<SubpatternSyntax>(new SyntaxNodeOrToken[] {
                                    Subpattern(
                                        DeclarationPattern(
                                            patternMatchSrcName,
                                            SingleVariableDesignation(Identifier(matchedSrcVarName)))),
                                    Token(SyntaxKind.CommaToken),
                                    Subpattern(
                                        DeclarationPattern(
                                            patternMatchDestName,
                                            SingleVariableDesignation(Identifier(matchedDestVarName))))
                                }))),
                        Token(SyntaxKind.ColonToken))))
            .WithStatements(List(expressions));
    }

    private static SwitchSectionSyntax CreateProjectToMethodSwitchSection(MapDefinition definition, MapDefinition.Mapping mapping) {
        var patternMatchSrcName = ParseTypeName(mapping.SourceName);
        var patternMatchDestName = ParseTypeName(mapping.DestinationName);
        var matchedSrcVarName = "s";
        var lambdaVarName = "src";

        var expressions = new List<SyntaxNodeOrToken>();
        var destMappings = definition.GetDestinationMappings(mapping);
        for (var i = 0; i < destMappings.Count; i++) {
            (var destProp, var srcProp) = destMappings[i];

            // Add a comma after the last expression before adding another
            if (expressions.Count > 0) {
                expressions.Add(Token(SyntaxKind.CommaToken));
            }

            var nullableParts = srcProp.Split(new[] { "?." }, StringSplitOptions.None);
            ExpressionSyntax expressionRight;

            expressionRight = MemberAccessExpression(
                SyntaxKind.SimpleMemberAccessExpression,
                IdentifierName(lambdaVarName),
                IdentifierName(string.Join(".", nullableParts))
            );
            if (nullableParts.Length > 1) {
                var binaryExpressions = new List<ExpressionSyntax>();

                // Do not consume the last nullable part as it is the final value
                // TODO: We do need to test it if a null fallback has been defined
                var nullCheckIdentifier = string.Empty;
                for (var j = 0; j < nullableParts.Length - 1; j++) {
                    if (nullCheckIdentifier.Length > 0) {
                        nullCheckIdentifier += ".";
                    }
                    nullCheckIdentifier += nullableParts[j];

                    binaryExpressions.Add(BinaryExpression(
                        SyntaxKind.NotEqualsExpression,
                        MemberAccessExpression(
                            SyntaxKind.SimpleMemberAccessExpression,
                            IdentifierName(lambdaVarName),
                            IdentifierName(nullCheckIdentifier)
                        ),
                        LiteralExpression(SyntaxKind.NullLiteralExpression)
                    ));
                }

                // Process the binary expressions in the reverse order in order to build them up correctly
                ExpressionSyntax condition = null!;
                for (var j = binaryExpressions.Count - 1; j >= 0; j--) {
                    condition = condition is null
                        ? binaryExpressions[j]
                        : BinaryExpression(
                            SyntaxKind.LogicalAndExpression,
                            binaryExpressions[j],
                            condition
                        );
                }

                expressionRight = ConditionalExpression(
                    condition,
                    expressionRight,
                    LiteralExpression(SyntaxKind.NullLiteralExpression)
                );
            }

            expressions.Add(
                AssignmentExpression(
                    SyntaxKind.SimpleAssignmentExpression,
                    IdentifierName(destProp),
                    expressionRight));
        }

        return SwitchSection()
            .WithLabels(
                SingletonList<SwitchLabelSyntax>(
                    CasePatternSwitchLabel(
                        RecursivePattern()
                        .WithPositionalPatternClause(
                            PositionalPatternClause(
                                SeparatedList<SubpatternSyntax>(new SyntaxNodeOrToken[] {
                                    Subpattern(
                                        DeclarationPattern(
                                            AliasQualifiedName(
                                                IdentifierName(Token(SyntaxKind.GlobalKeyword)),
                                                GenericName(Identifier(typeof(IQueryable).FullName))
                                                .WithTypeArgumentList(
                                                    TypeArgumentList(SingletonSeparatedList(patternMatchSrcName)))
                                            ),
                                            SingleVariableDesignation(Identifier(matchedSrcVarName))
                                        )),
                                    Token(SyntaxKind.CommaToken),
                                    Subpattern(
                                        ConstantPattern(ParseExpression(mapping.DestinationName)))
                                }))),
                        Token(SyntaxKind.ColonToken))))
            .WithStatements(
                SingletonList<StatementSyntax>(
                    ReturnStatement(
                        InvocationExpression(
                            MemberAccessExpression(
                                SyntaxKind.SimpleMemberAccessExpression,
                                MemberAccessExpression(
                                    SyntaxKind.SimpleMemberAccessExpression,
                                    AliasQualifiedName(
                                        IdentifierName(Token(SyntaxKind.GlobalKeyword)),
                                        IdentifierName(typeof(Queryable).Namespace)
                                    ),
                                    IdentifierName(nameof(Queryable))),
                                GenericName(Identifier(nameof(Queryable.Cast)))
                                .WithTypeArgumentList(
                                    TypeArgumentList(
                                        SingletonSeparatedList<TypeSyntax>(IdentifierName(GENERIC_TYPE_NAME_DESTINATION))))))
                        .WithArgumentList(
                            ArgumentList(
                                SingletonSeparatedList(
                                    Argument(
                                        InvocationExpression(
                                            MemberAccessExpression(
                                                SyntaxKind.SimpleMemberAccessExpression,
                                                MemberAccessExpression(
                                                    SyntaxKind.SimpleMemberAccessExpression,
                                                    AliasQualifiedName(
                                                        IdentifierName(Token(SyntaxKind.GlobalKeyword)),
                                                        IdentifierName(typeof(Queryable).Namespace)),
                                                    IdentifierName(nameof(Queryable))),
                                                IdentifierName(nameof(Queryable.Select))))
                                        .WithArgumentList(
                                            ArgumentList(
                                                SeparatedList<ArgumentSyntax>(new SyntaxNodeOrToken[] {
                                                    Argument(IdentifierName(matchedSrcVarName)),
                                                    Token(SyntaxKind.CommaToken),
                                                    Argument(SimpleLambdaExpression(
                                                        Parameter(Identifier(lambdaVarName)))
                                                    .WithExpressionBody(
                                                        ObjectCreationExpression(patternMatchDestName)
                                                        .WithArgumentList(ArgumentList())
                                                        .WithInitializer(
                                                            InitializerExpression(
                                                                SyntaxKind.ObjectInitializerExpression,
                                                                SeparatedList<ExpressionSyntax>(expressions)))))
                                                }))))))))));
    }

    private static SwitchSectionSyntax CreateDefaultSwitchThrow(string sourceVarName)
        => SwitchSection()
        .WithLabels(SingletonList<SwitchLabelSyntax>(DefaultSwitchLabel()))
        .WithStatements(SingletonList<StatementSyntax>(
            ThrowStatement(
                ObjectCreationExpression(
                    //IdentifierName(nameof(MappingException))) // TODO: This currently does not work in consuming project. Need to investigate why
                    IdentifierName("MappingException"))
                .WithArgumentList(
                    ArgumentList(
                        SingletonSeparatedList(
                            Argument(
                                InterpolatedStringExpression(
                                        Token(SyntaxKind.InterpolatedStringStartToken))
                                .WithContents(List(new InterpolatedStringContentSyntax[] {
                                InterpolatedStringText()
                                .WithTextToken(Token(
                                    TriviaList(),
                                    SyntaxKind.InterpolatedStringTextToken,
                                    "Mapping from ",
                                    "Mapping from ",
                                    TriviaList())),
                                Interpolation(MemberAccessExpression(
                                    SyntaxKind.SimpleMemberAccessExpression,
                                    InvocationExpression(
                                        MemberAccessExpression(
                                            SyntaxKind.SimpleMemberAccessExpression,
                                            IdentifierName(sourceVarName),
                                            IdentifierName("GetType"))),
                                    IdentifierName("Name"))),
                                InterpolatedStringText()
                                .WithTextToken(Token(
                                    TriviaList(),
                                    SyntaxKind.InterpolatedStringTextToken,
                                    " to ",
                                    " to ",
                                    TriviaList())),
                                Interpolation(
                                    MemberAccessExpression(
                                        SyntaxKind.SimpleMemberAccessExpression,
                                        TypeOfExpression(
                                            IdentifierName(GENERIC_TYPE_NAME_DESTINATION)),
                                        IdentifierName("Name"))),
                                InterpolatedStringText()
                                .WithTextToken(Token(
                                    TriviaList(),
                                    SyntaxKind.InterpolatedStringTextToken,
                                    " has not been configured.",
                                    " has not been configured.",
                                    TriviaList()))
                                })))))))));

    private static TypeDeclarationSyntax WithAutoGeneratedCodeAttributes(this TypeDeclarationSyntax interfaceDeclaration, bool withCodeCoverageExclusion = false) {
        var attributes = new List<AttributeListSyntax> {
            // Generated-Code Attribute
            AttributeList(SingletonSeparatedList(
                Attribute(
                    AliasQualifiedName(
                        IdentifierName(Token(SyntaxKind.GlobalKeyword)),
                        FullAttributeDisplayIdentifier<System.CodeDom.Compiler.GeneratedCodeAttribute>()
                    )
                )
                .WithArgumentList(
                    AttributeArgumentList(SeparatedList<AttributeArgumentSyntax>(new SyntaxNodeOrToken[] {
                        AttributeArgument(
                            LiteralExpression(
                                SyntaxKind.StringLiteralExpression,
                                Literal(typeof(MapperGenerator).FullName))),
                        Token(SyntaxKind.CommaToken),
                        AttributeArgument(
                            LiteralExpression(
                                SyntaxKind.StringLiteralExpression,
                                Literal(_generatorVersion)))
                    })))))
        };
        if (withCodeCoverageExclusion) {
            attributes.Add(
                // ExcludeFromCodeCoverage attribute
                AttributeList(SingletonSeparatedList(
                    Attribute(
                        AliasQualifiedName(
                            IdentifierName(Token(SyntaxKind.GlobalKeyword)),
                            FullAttributeDisplayIdentifier<System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverageAttribute>()
                        )
                    )))
            );
        }

        return interfaceDeclaration.WithAttributeLists(List(attributes));
    }

    private static IdentifierNameSyntax FullAttributeDisplayIdentifier<TAttribute>() where TAttribute : Attribute {
        var attrName = typeof(TAttribute).FullName;
        var attrSuffix = "Attribute";
        return IdentifierName(attrName.Substring(0, attrName.Length - attrSuffix.Length));
    }
}
