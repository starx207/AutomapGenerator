using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;

namespace AutomapGenerator.SourceGenerator.Internal;

internal static class MapGenHelper {
    private const string INDENT = "    ";
    private const string MAP_METHOD_NAME = "Map";
    private const string PROJECTTO_METHOD_NAME = "ProjectTo";
    private const string GENERIC_TYPE_NAME_DESTINATION = "TDestination";
    private const string MAPPER_INTERFACE = "IMapper";
    private static readonly string _generatorVersion = typeof(MapperGenerator).Assembly.GetName().Version.ToString();

    public static NamespaceDeclarationSyntax CreateMapperClass(MapDefinition[] sources) {
        var mapperMethods = new List<MemberDeclarationSyntax> {
            CreateMapNewMethod(INDENT + INDENT)
        };
        var mapExistingMethods = CreateMapExistingMethods(INDENT + INDENT, sources);
        for (var i = 0; i < mapExistingMethods.Count; i++) {
            mapperMethods.Add(mapExistingMethods[i].WithTrailingTrivia(CarriageReturnLineFeed, CarriageReturnLineFeed));
        }
        var projectMethods = CreateProjectToMethods(INDENT + INDENT, sources);
        for (var i = 0; i < projectMethods.Count; i++) {
            if (i == projectMethods.Count - 1) {
                // Don't add trailing trivia to the last method
                mapperMethods.Add(projectMethods[i]);
            } else {
                mapperMethods.Add(projectMethods[i].WithTrailingTrivia(CarriageReturnLineFeed, CarriageReturnLineFeed));
            }
        }

        return CreateCoreNamespace()
        .WithMembers(
            SingletonList<MemberDeclarationSyntax>(
                //ClassDeclaration("Mapper")
                ClassDeclaration(Identifier(
                    TriviaList(Space),
                    "Mapper",
                    TriviaList(Space)))
                .WithAutoGeneratedCodeAttributes(INDENT, withCodeCoverageExclusion: true)
                .WithModifiers(
                    TokenList(Token(
                        TriviaList(Whitespace(INDENT)),
                        SyntaxKind.PublicKeyword,
                        TriviaList(Space))))
                .WithBaseList(
                    BaseList(
                        SingletonSeparatedList<BaseTypeSyntax>(
                            SimpleBaseType(IdentifierName(MAPPER_INTERFACE))
                                .WithLeadingTrivia(Space))))
                .WithOpenBraceToken(Token(
                    TriviaList(CarriageReturnLineFeed, Whitespace(INDENT)),
                    SyntaxKind.OpenBraceToken,
                    TriviaList(CarriageReturnLineFeed)))
                .WithCloseBraceToken(Token(
                    TriviaList(CarriageReturnLineFeed, Whitespace(INDENT)),
                    SyntaxKind.CloseBraceToken,
                    TriviaList()))
                .WithMembers(List(mapperMethods))));
    }

    private static MethodDeclarationSyntax CreateMapNewSignature(string sourceParamName, string indentation)
        => MethodDeclaration(
            IdentifierName(GENERIC_TYPE_NAME_DESTINATION),
            Identifier(TriviaList(Space), MAP_METHOD_NAME, TriviaList()))
        .WithTypeParameterList(
            TypeParameterList(
                SingletonSeparatedList(
                    TypeParameter(Identifier(GENERIC_TYPE_NAME_DESTINATION)))))
        .WithParameterList(
            ParameterList(
                SingletonSeparatedList(
                    Parameter(
                        Identifier(sourceParamName))
                    .WithType(PredefinedType(Token(
                        TriviaList(),
                        SyntaxKind.ObjectKeyword,
                        TriviaList(Space))))))
            .WithTrailingTrivia(CarriageReturnLineFeed))
        .WithConstraintClauses(
            SingletonList(
                TypeParameterConstraintClause(
                    Token(
                        TriviaList(Whitespace(indentation + INDENT)),
                        SyntaxKind.WhereKeyword,
                        TriviaList(Space)),
                    IdentifierName(GENERIC_TYPE_NAME_DESTINATION),
                    Token(
                        TriviaList(Space),
                        SyntaxKind.ColonToken,
                        TriviaList(Space)),
                    SingletonSeparatedList<TypeParameterConstraintSyntax>(
                        ConstructorConstraint()))));

    private static MethodDeclarationSyntax CreateMapExistingSignature(string sourceParamName, string destinationParamName)
        => MethodDeclaration(
            IdentifierName(GENERIC_TYPE_NAME_DESTINATION),
            Identifier(
                TriviaList(Space),
                MAP_METHOD_NAME,
                TriviaList()))
        .WithTypeParameterList(
            TypeParameterList(
                SingletonSeparatedList(
                    TypeParameter(
                        Identifier(GENERIC_TYPE_NAME_DESTINATION)))))
        .WithParameterList(
            ParameterList(
                SeparatedList<ParameterSyntax>(new SyntaxNodeOrToken[] {
                    Parameter(Identifier(TriviaList(Space), sourceParamName, TriviaList())).WithType(PredefinedType(Token(SyntaxKind.ObjectKeyword))),
                    Token(TriviaList(), SyntaxKind.CommaToken, TriviaList(Space)),
                    Parameter(Identifier(TriviaList(Space), destinationParamName, TriviaList())).WithType(IdentifierName(GENERIC_TYPE_NAME_DESTINATION))
                })));

    private static MethodDeclarationSyntax CreateProjectToSignature(string sourceParamName, string indentation)
        => MethodDeclaration(
                AliasQualifiedName(
                    IdentifierName(Token(SyntaxKind.GlobalKeyword)),
                    GenericName(Identifier(typeof(IQueryable).FullName))
                    .WithTypeArgumentList(TypeArgumentList(
                        SingletonSeparatedList<TypeSyntax>(IdentifierName(GENERIC_TYPE_NAME_DESTINATION))
                    ))
                    .WithTrailingTrivia(Space)
                ),
                Identifier(PROJECTTO_METHOD_NAME))
        .WithTypeParameterList(TypeParameterList(
            SingletonSeparatedList(
                TypeParameter(Identifier(GENERIC_TYPE_NAME_DESTINATION))
            )))
        .WithParameterList(ParameterList(
            SingletonSeparatedList(
                Parameter(Identifier(
                    TriviaList(Space),
                    sourceParamName,
                    TriviaList()))
                .WithType(
                    AliasQualifiedName(
                        IdentifierName(Token(SyntaxKind.GlobalKeyword)),
                        GenericName(Identifier(typeof(IQueryable).FullName))
                        .WithTypeArgumentList(TypeArgumentList(
                            SingletonSeparatedList<TypeSyntax>(PredefinedType(Token(SyntaxKind.ObjectKeyword)))
                        ))
                    ))
            )))
        .WithConstraintClauses(SingletonList(
            TypeParameterConstraintClause(
                IdentifierName(GENERIC_TYPE_NAME_DESTINATION)
                .WithLeadingTrivia(Space)
                .WithTrailingTrivia(Space))
            .WithConstraints(SingletonSeparatedList<TypeParameterConstraintSyntax>(
                ConstructorConstraint()
                .WithLeadingTrivia(Space)))
            .WithLeadingTrivia(CarriageReturnLineFeed, Whitespace(indentation + INDENT))
        ));

    private static NamespaceDeclarationSyntax CreateCoreNamespace()
        => NamespaceDeclaration(
            //IdentifierName(typeof(MappingException).Namespace)) // TODO: This currently does not work in consuming project. Need to investigate why
            IdentifierName("AutomapGenerator"))
        .WithNamespaceKeyword(
            Token(
                TriviaList(Comment("// <auto-generated/>"), CarriageReturnLineFeed),
                SyntaxKind.NamespaceKeyword,
                TriviaList(Space)))
        .WithOpenBraceToken(
            Token(
                TriviaList(CarriageReturnLineFeed),
                SyntaxKind.OpenBraceToken,
                TriviaList(CarriageReturnLineFeed)))
        .WithCloseBraceToken(
            Token(
                TriviaList(CarriageReturnLineFeed),
                SyntaxKind.CloseBraceToken,
                TriviaList(CarriageReturnLineFeed)));

    private static MethodDeclarationSyntax CreateMapNewMethod(string indentation) {
        var sourceVarName = "source";

        return CreateMapNewSignature(sourceVarName, indentation)
            .WithModifiers(
                TokenList(Token(
                    TriviaList(Whitespace(indentation)),
                    SyntaxKind.PublicKeyword,
                    TriviaList(Space))))
            .WithExpressionBody(
                ArrowExpressionClause(
                    InvocationExpression(
                        GenericName(
                            Identifier(MAP_METHOD_NAME))
                        .WithTypeArgumentList(
                            TypeArgumentList(
                                SingletonSeparatedList<TypeSyntax>(IdentifierName(GENERIC_TYPE_NAME_DESTINATION)))))
                    .WithLeadingTrivia(Space)
                    .WithArgumentList(
                        ArgumentList(
                            SeparatedList<ArgumentSyntax>(new SyntaxNodeOrToken[] {
                                Argument(IdentifierName(sourceVarName)),
                                Token(
                                    TriviaList(),
                                    SyntaxKind.CommaToken,
                                    TriviaList(Space)),
                                Argument(
                                    ObjectCreationExpression(IdentifierName(GENERIC_TYPE_NAME_DESTINATION).WithLeadingTrivia(Space))
                                    .WithArgumentList(ArgumentList()))
                            }))))
                .WithLeadingTrivia(Space))
            .WithSemicolonToken(Token(
                TriviaList(),
                SyntaxKind.SemicolonToken,
                TriviaList(CarriageReturnLineFeed)));
    }

    private static List<MethodDeclarationSyntax> CreateMapExistingMethods(string indentation, MapDefinition[] srcMappings) {
        var destinationVarName = "destination";
        var sourceVarName = "source";

        var internalMapMethods = new List<MethodDeclarationSyntax>();
        var switchSections = new List<SwitchSectionSyntax>();
        for (var i = 0; i < srcMappings.Length; i++) {
            var definition = srcMappings[i];
            for (var j = 0; j < definition.Mappings.Count; j++) {
                var mapping = definition.Mappings[j];
                if (!mapping.ProjectionOnly) {
                    var mapMethod = CreateInternalMapMethod(definition, mapping, indentation);
                    internalMapMethods.Add(mapMethod);
                    switchSections.Add(CreateMapMethodSwitchSection(mapMethod, indentation + INDENT + INDENT));
                }
            }
        }

        // Add the default switch section 
        switchSections.Add(CreateDefaultSwitchThrow(sourceVarName, indentation + INDENT + INDENT));

        // Add the public method at the beginning
        internalMapMethods.Insert(0,
            CreateMapExistingSignature(sourceVarName, destinationVarName)
                .WithModifiers(
                    TokenList(
                        Token(
                            TriviaList(Whitespace(indentation)),
                            SyntaxKind.PublicKeyword,
                            TriviaList(Space))))
                .WithBody(
                    Block(
                        SwitchStatement(
                            TupleExpression(
                                SeparatedList<ArgumentSyntax>(new SyntaxNodeOrToken[] {
                                        Argument(IdentifierName(sourceVarName)),
                                        Token(TriviaList(), SyntaxKind.CommaToken, TriviaList(Space)),
                                        Argument(IdentifierName(destinationVarName))
                                }))
                            .WithLeadingTrivia(Space))
                        .WithLeadingTrivia(Whitespace(indentation + INDENT))
                        .WithOpenBraceToken(Token(
                            TriviaList(CarriageReturnLineFeed, Whitespace(indentation + INDENT)),
                            SyntaxKind.OpenBraceToken,
                            TriviaList(CarriageReturnLineFeed)))
                        .WithSections(List(switchSections))
                        .WithCloseBraceToken(Token(
                            TriviaList(CarriageReturnLineFeed, Whitespace(indentation + INDENT)),
                            SyntaxKind.CloseBraceToken,
                            TriviaList(CarriageReturnLineFeed))),
                        ReturnStatement(IdentifierName(destinationVarName).WithLeadingTrivia(Space))
                            .WithLeadingTrivia(CarriageReturnLineFeed, Whitespace(indentation + INDENT))
                    )
                    .WithOpenBraceToken(Token(
                        TriviaList(CarriageReturnLineFeed, Whitespace(indentation)),
                        SyntaxKind.OpenBraceToken,
                        TriviaList(CarriageReturnLineFeed)))
                    .WithCloseBraceToken(Token(
                        TriviaList(CarriageReturnLineFeed, Whitespace(indentation)),
                        SyntaxKind.CloseBraceToken,
                        TriviaList())))
        );
        return internalMapMethods;
    }

    private static List<MethodDeclarationSyntax> CreateProjectToMethods(string indentation, MapDefinition[] srcMappings) {
        var destinationVarName = "destInstance";
        var sourceVarName = "source";

        var internalProjectMethods = new List<MethodDeclarationSyntax>();
        var switchSections = new List<SwitchSectionSyntax>();
        for (var i = 0; i < srcMappings.Length; i++) {
            var definition = srcMappings[i];
            for (var j = 0; j < definition.Mappings.Count; j++) {
                var projectMethod = CreateInternalProjectMethod(definition, definition.Mappings[j], indentation);
                internalProjectMethods.Add(projectMethod);
                switchSections.Add(CreateProjectToMethodSwitchSection(projectMethod, indentation + INDENT + INDENT));
            }
        }

        // Add the default switch section
        switchSections.Add(CreateDefaultSwitchThrow(sourceVarName, indentation + INDENT + INDENT));

        // Add the public method at the beginning
        internalProjectMethods.Insert(0, 
            CreateProjectToSignature(sourceVarName, indentation)
                .WithModifiers(
                    TokenList(Token(
                        TriviaList(Whitespace(indentation)),
                        SyntaxKind.PublicKeyword,
                        TriviaList(Space))))
                .WithBody(
                    Block(
                        LocalDeclarationStatement(
                            VariableDeclaration(
                                IdentifierName(
                                    Identifier(
                                        TriviaList(),
                                        SyntaxKind.VarKeyword,
                                        "var",
                                        "var",
                                        TriviaList(Space))))
                            .WithVariables(
                                SingletonSeparatedList(
                                    VariableDeclarator(
                                        Identifier(destinationVarName)
                                        .WithTrailingTrivia(Space))
                                    .WithInitializer(
                                        EqualsValueClause(
                                            ObjectCreationExpression(
                                                IdentifierName(GENERIC_TYPE_NAME_DESTINATION)
                                                .WithLeadingTrivia(Space))
                                            .WithLeadingTrivia(Space)
                                            .WithArgumentList(ArgumentList()))))))
                        .WithLeadingTrivia(Whitespace(indentation + INDENT))
                        .WithTrailingTrivia(CarriageReturnLineFeed),

                        SwitchStatement(
                            TupleExpression(
                                SeparatedList<ArgumentSyntax>(new SyntaxNodeOrToken[] {
                                    Argument(IdentifierName(sourceVarName)),
                                    Token(TriviaList(), SyntaxKind.CommaToken, TriviaList(Space)),
                                    Argument(IdentifierName(destinationVarName))
                                }))
                            .WithLeadingTrivia(Space))
                        .WithLeadingTrivia(Whitespace(indentation + INDENT))
                        .WithOpenBraceToken(Token(
                            TriviaList(CarriageReturnLineFeed, Whitespace(indentation + INDENT)),
                            SyntaxKind.OpenBraceToken,
                            TriviaList(CarriageReturnLineFeed)))
                        .WithSections(List(switchSections))
                        .WithCloseBraceToken(Token(
                            TriviaList(CarriageReturnLineFeed, Whitespace(indentation + INDENT)),
                            SyntaxKind.CloseBraceToken,
                            TriviaList()))
                    )
                    .WithOpenBraceToken(Token(
                        TriviaList(CarriageReturnLineFeed, Whitespace(indentation)),
                        SyntaxKind.OpenBraceToken,
                        TriviaList(CarriageReturnLineFeed)))
                    .WithCloseBraceToken(Token(
                        TriviaList(CarriageReturnLineFeed, Whitespace(indentation)),
                        SyntaxKind.CloseBraceToken,
                        TriviaList())))
        );
        return internalProjectMethods;
    }

    private static MethodDeclarationSyntax CreateInternalMapMethod(MapDefinition definition, MapDefinition.Mapping mapping, string indentation) {
        var patternMatchSrcName = ParseTypeName(mapping.SourceName);
        var patternMatchDestName = ParseTypeName(mapping.DestinationName);
        var matchedSrcVarName = "source";
        var matchedDestVarName = "destination";

        var expressions = new List<StatementSyntax>();
        var destMappings = definition.GetDestinationMappings(mapping);
        for (var i = 0; i < destMappings.Count; i++) {
            (var destProp, var srcProp, var fallback, var constFallback) = destMappings[i];

            ExpressionSyntax srcExpr = MemberAccessExpression(
                SyntaxKind.SimpleMemberAccessExpression,
                IdentifierName(matchedSrcVarName).WithLeadingTrivia(Space),
                IdentifierName(srcProp)
            );
            if (fallback is not null) {
                srcExpr = BinaryExpression(
                    SyntaxKind.CoalesceExpression,
                    srcExpr.WithTrailingTrivia(Space),
                    (constFallback
                        ? IdentifierName(fallback)
                        : (ExpressionSyntax)MemberAccessExpression(
                            SyntaxKind.SimpleMemberAccessExpression,
                            IdentifierName(matchedSrcVarName),
                            IdentifierName(fallback)))
                    .WithLeadingTrivia(Space)
                );
            }

            expressions.Add(ExpressionStatement(
                AssignmentExpression(
                    SyntaxKind.SimpleAssignmentExpression,
                    MemberAccessExpression(
                        SyntaxKind.SimpleMemberAccessExpression,
                        IdentifierName(matchedDestVarName),
                        IdentifierName(destProp).WithTrailingTrivia(Space)),
                    srcExpr))
                .WithLeadingTrivia(Whitespace(indentation + INDENT))
                .WithTrailingTrivia(CarriageReturnLineFeed));
        }

        return MethodDeclaration(
            PredefinedType(Token(SyntaxKind.VoidKeyword)),
            Identifier(
                TriviaList(Space),
                "MapInternal",
                TriviaList())
        ).WithModifiers(TokenList(
            Token(
                TriviaList(Whitespace(indentation)),
                SyntaxKind.PrivateKeyword,
                TriviaList(Space))
        )).WithParameterList(ParameterList(SeparatedList<ParameterSyntax>(new SyntaxNodeOrToken[] {
            Parameter(Identifier(TriviaList(Space), matchedSrcVarName, TriviaList())).WithType(patternMatchSrcName),
            Token(TriviaList(), SyntaxKind.CommaToken, TriviaList(Space)),
            Parameter(Identifier(TriviaList(Space), matchedDestVarName, TriviaList())).WithType(patternMatchDestName)
        })))
        .WithBody(
            Block(expressions)
            .WithOpenBraceToken(Token(
                TriviaList(CarriageReturnLineFeed, Whitespace(indentation)),
                SyntaxKind.OpenBraceToken,
                TriviaList(CarriageReturnLineFeed)))
            .WithCloseBraceToken(Token(
                TriviaList(Whitespace(indentation)),
                SyntaxKind.CloseBraceToken,
                TriviaList())));
    }

    private static SwitchSectionSyntax CreateMapMethodSwitchSection(MethodDeclarationSyntax mapMethod, string indentation) {
        var patternMatchSrcName = mapMethod.ParameterList.Parameters[0].Type!;
        var patternMatchDestName = mapMethod.ParameterList.Parameters[1].Type!;
        var matchedSrcVarName = "s";
        var matchedDestVarName = "d";

        return SwitchSection()
            .WithLabels(
                SingletonList<SwitchLabelSyntax>(
                    CasePatternSwitchLabel(
                        RecursivePattern()
                        .WithPositionalPatternClause(
                            PositionalPatternClause(
                                SeparatedList<SubpatternSyntax>(new SyntaxNodeOrToken[] {
                                    Subpattern(
                                        DeclarationPattern(
                                            patternMatchSrcName,
                                            SingleVariableDesignation(Identifier(
                                                TriviaList(Space),
                                                matchedSrcVarName,
                                                TriviaList())))),
                                    Token(
                                        TriviaList(),
                                        SyntaxKind.CommaToken,
                                        TriviaList(Space)),
                                    Subpattern(
                                        DeclarationPattern(
                                            patternMatchDestName,
                                            SingleVariableDesignation(Identifier(
                                                TriviaList(Space),
                                                matchedDestVarName,
                                                TriviaList()))))
                                }))
                            .WithLeadingTrivia(Space)),
                        Token(SyntaxKind.ColonToken))))
            .WithLeadingTrivia(Whitespace(indentation))
            .WithTrailingTrivia(CarriageReturn)
            .WithStatements(List(new StatementSyntax[] {
                ExpressionStatement(
                    InvocationExpression(IdentifierName(mapMethod.Identifier.Text))
                        .WithArgumentList(ArgumentList(SeparatedList<ArgumentSyntax>(new SyntaxNodeOrToken[] {
                            Argument(IdentifierName(matchedSrcVarName)),
                            Token(SyntaxKind.CommaToken).WithTrailingTrivia(Space),
                            Argument(IdentifierName(matchedDestVarName))
                        }))))
                    .WithLeadingTrivia(Whitespace(indentation + INDENT))
                    .WithTrailingTrivia(CarriageReturnLineFeed),
                BreakStatement()
                    .WithLeadingTrivia(Whitespace(indentation + INDENT))
                    .WithTrailingTrivia(CarriageReturnLineFeed)
            }));
    }

    private static MethodDeclarationSyntax CreateInternalProjectMethod(MapDefinition definition, MapDefinition.Mapping mapping, string indentation) {
        var patternMatchSrcName = WrapTypeInIQueryable(ParseTypeName(mapping.SourceName));
        var patternMatchDestName = ParseTypeName(mapping.DestinationName);
        var matchedSrcVarName = "sourceQueryable";
        var lambdaVarName = "source";

        var expressions = new List<SyntaxNodeOrToken>();
        var destMappings = definition.GetDestinationMappings(mapping);
        for (var i = 0; i < destMappings.Count; i++) {
            (var destProp, var srcProp, var fallback, var constFallback) = destMappings[i];

            // Add a comma after the last expression before adding another
            if (expressions.Count > 0) {
                expressions.Add(Token(
                    TriviaList(),
                    SyntaxKind.CommaToken,
                    TriviaList(CarriageReturnLineFeed)));
            }

            var srcNullableParts = srcProp.Split(new[] { "?." }, StringSplitOptions.None);
            ExpressionSyntax? fallbackExpr = null;
            if (fallback is not null) {
                fallbackExpr = constFallback
                    ? IdentifierName(fallback)
                    : BuildLinqExpressionWithNullChecks(lambdaVarName, fallback.Split(new[] { "?." }, StringSplitOptions.None));
            }

            var expressionRight = BuildLinqExpressionWithNullChecks(lambdaVarName, srcNullableParts, fallbackExpr);

            expressions.Add(
                AssignmentExpression(
                    SyntaxKind.SimpleAssignmentExpression,
                    IdentifierName(destProp)
                        .WithLeadingTrivia(Whitespace(indentation + INDENT + INDENT))
                        .WithTrailingTrivia(Space),
                    expressionRight.WithLeadingTrivia(Space)));
        }

        var objectInitializerExpression = ObjectCreationExpression(patternMatchDestName)
            .WithNewKeyword(Token(
                TriviaList(Space),
                SyntaxKind.NewKeyword,
                TriviaList(Space)))
            .WithArgumentList(ArgumentList());

        if (expressions.Count > 0) {
            objectInitializerExpression = objectInitializerExpression
                .WithInitializer(
                    InitializerExpression(
                        SyntaxKind.ObjectInitializerExpression,
                        SeparatedList<ExpressionSyntax>(expressions))
                    .WithOpenBraceToken(Token(
                        TriviaList(CarriageReturnLineFeed, Whitespace(indentation + INDENT)),
                        SyntaxKind.OpenBraceToken,
                        TriviaList(CarriageReturnLineFeed)))
                    .WithCloseBraceToken(Token(
                        TriviaList(CarriageReturnLineFeed, Whitespace(indentation + INDENT)),
                        SyntaxKind.CloseBraceToken,
                        TriviaList())));
        }

        return MethodDeclaration(
            WrapTypeInIQueryable(patternMatchDestName),
            Identifier(
                TriviaList(Space),
                "ProjectInternal",
                TriviaList())
        ).WithModifiers(TokenList(
            Token(
                TriviaList(Whitespace(indentation)),
                SyntaxKind.PrivateKeyword,
                TriviaList(Space))
        )).WithParameterList(ParameterList(SeparatedList<ParameterSyntax>(new SyntaxNodeOrToken[] {
            Parameter(Identifier(TriviaList(Space), matchedSrcVarName, TriviaList())).WithType(patternMatchSrcName),
            Token(TriviaList(), SyntaxKind.CommaToken, TriviaList(Space)),
            Parameter(Identifier(TriviaList(Space), "_", TriviaList())).WithType(patternMatchDestName)
        })))
        .WithBody(
            Block(SingletonList<StatementSyntax>(
                ReturnStatement(
                    InvocationExpression(
                        MemberAccessExpression(
                            SyntaxKind.SimpleMemberAccessExpression,
                            MemberAccessExpression(
                                SyntaxKind.SimpleMemberAccessExpression,
                                AliasQualifiedName(
                                    IdentifierName(Token(SyntaxKind.GlobalKeyword)),
                                    IdentifierName(typeof(Queryable).Namespace)),
                                IdentifierName(nameof(Queryable))),
                            IdentifierName(nameof(Queryable.Select))))
                    .WithLeadingTrivia(Space)
                    .WithArgumentList(
                        ArgumentList(
                            SeparatedList<ArgumentSyntax>(new SyntaxNodeOrToken[] {
                                Argument(IdentifierName(matchedSrcVarName)),
                                Token(
                                    TriviaList(),
                                    SyntaxKind.CommaToken,
                                    TriviaList(Space)),
                                Argument(SimpleLambdaExpression(
                                    Parameter(Identifier(
                                        TriviaList(),
                                        lambdaVarName,
                                        TriviaList(Space))))
                                .WithExpressionBody(objectInitializerExpression))
                            }))))
                .WithLeadingTrivia(Whitespace(indentation + INDENT))
                .WithTrailingTrivia(CarriageReturnLineFeed)
            )).WithOpenBraceToken(Token(
                TriviaList(CarriageReturnLineFeed, Whitespace(indentation)),
                SyntaxKind.OpenBraceToken,
                TriviaList(CarriageReturnLineFeed)))
            .WithCloseBraceToken(Token(
                TriviaList(Whitespace(indentation)),
                SyntaxKind.CloseBraceToken,
                TriviaList())));
    }

    private static TypeSyntax WrapTypeInIQueryable(TypeSyntax innerType) 
        => QualifiedName(
            AliasQualifiedName(
                IdentifierName(Token(SyntaxKind.GlobalKeyword)),
                IdentifierName(typeof(IQueryable).Namespace)),
            GenericName(nameof(IQueryable))
                .WithTypeArgumentList(TypeArgumentList(
                    SingletonSeparatedList(innerType))));

    private static SwitchSectionSyntax CreateProjectToMethodSwitchSection(MethodDeclarationSyntax projectMethod, string indentation) {
        var patternMatchSrcName = projectMethod.ParameterList.Parameters[0].Type!;
        var patternMatchDestName = projectMethod.ParameterList.Parameters[1].Type!;
        var matchedSrcVarName = "s";
        var matchedDestVarName = "d";

        return SwitchSection()
            .WithLabels(
                SingletonList<SwitchLabelSyntax>(
                    CasePatternSwitchLabel(
                        RecursivePattern()
                        .WithPositionalPatternClause(
                            PositionalPatternClause(
                                SeparatedList<SubpatternSyntax>(new SyntaxNodeOrToken[] {
                                    Subpattern(
                                        DeclarationPattern(
                                            patternMatchSrcName,
                                            SingleVariableDesignation(Identifier(
                                                TriviaList(Space),
                                                matchedSrcVarName,
                                                TriviaList()))
                                        )),
                                    Token(
                                        TriviaList(),
                                        SyntaxKind.CommaToken,
                                        TriviaList(Space)),
                                    Subpattern(
                                        DeclarationPattern(
                                            patternMatchDestName,
                                            SingleVariableDesignation(Identifier(
                                                TriviaList(Space),
                                                matchedDestVarName,
                                                TriviaList()))))
                                })))
                        .WithLeadingTrivia(Space),
                        Token(SyntaxKind.ColonToken))
                    .WithLeadingTrivia(Whitespace(indentation))
                    .WithTrailingTrivia(CarriageReturnLineFeed)))
            .WithStatements(
                SingletonList<StatementSyntax>(
                    ReturnStatement(
                        InvocationExpression(
                            MemberAccessExpression(
                                SyntaxKind.SimpleMemberAccessExpression,
                                MemberAccessExpression(
                                    SyntaxKind.SimpleMemberAccessExpression,
                                    AliasQualifiedName(
                                        IdentifierName(Token(SyntaxKind.GlobalKeyword)),
                                        IdentifierName(typeof(Queryable).Namespace)
                                    ),
                                    IdentifierName(nameof(Queryable))),
                                GenericName(Identifier(nameof(Queryable.Cast)))
                                .WithTypeArgumentList(
                                    TypeArgumentList(
                                        SingletonSeparatedList<TypeSyntax>(IdentifierName(GENERIC_TYPE_NAME_DESTINATION))))))
                        .WithLeadingTrivia(Space)
                        .WithArgumentList(
                            ArgumentList(
                                SingletonSeparatedList(
                                    Argument(
                                        InvocationExpression(IdentifierName(projectMethod.Identifier.Text))
                                            .WithArgumentList(ArgumentList(SeparatedList<ArgumentSyntax>(new SyntaxNodeOrToken[] {
                                                Argument(IdentifierName(matchedSrcVarName)),
                                                Token(SyntaxKind.CommaToken).WithTrailingTrivia(Space),
                                                Argument(IdentifierName(matchedDestVarName)),
                                            })))
                                        )))))
                    .WithLeadingTrivia(Whitespace(indentation + INDENT))
                    .WithTrailingTrivia(CarriageReturnLineFeed)));
    }

    private static ExpressionSyntax BuildLinqExpressionWithNullChecks(string lambdaVarName, string[] nullableParts, ExpressionSyntax? nullFallback = null) {
        var memberExpr = MemberAccessExpression(
            SyntaxKind.SimpleMemberAccessExpression,
            IdentifierName(lambdaVarName),
            IdentifierName(string.Join(".", nullableParts))
        );

        if (nullFallback is ConditionalExpressionSyntax) {
            nullFallback = ParenthesizedExpression(nullFallback);
        }

        if (nullableParts.Length <= 1) {
            return nullFallback is not null
                ? ConditionalExpression(BinaryExpression(
                    SyntaxKind.NotEqualsExpression,
                    memberExpr.WithTrailingTrivia(Space),
                    LiteralExpression(SyntaxKind.NullLiteralExpression).WithLeadingTrivia(Space).WithTrailingTrivia(Space)),
                    memberExpr.WithLeadingTrivia(Space).WithTrailingTrivia(Space),
                    nullFallback.WithLeadingTrivia(Space))
                : memberExpr;
        }

        var binaryExpressions = new List<ExpressionSyntax>();

        // Do not consume the last nullable part as it is the final value
        var nullCheckIdentifier = string.Empty;
        var offset = nullFallback is null ? 1 : 0;
        for (var i = 0; i < nullableParts.Length - offset; i++) {
            if (nullCheckIdentifier.Length > 0) {
                nullCheckIdentifier += ".";
            }
            nullCheckIdentifier += nullableParts[i];

            binaryExpressions.Add(BinaryExpression(
                SyntaxKind.NotEqualsExpression,
                MemberAccessExpression(
                    SyntaxKind.SimpleMemberAccessExpression,
                    IdentifierName(lambdaVarName),
                    IdentifierName(nullCheckIdentifier)
                ).WithTrailingTrivia(Space),
                LiteralExpression(SyntaxKind.NullLiteralExpression)
                .WithLeadingTrivia(Space)
            ));
        }

        // Process the binary expressions in the reverse order in order to build them up correctly
        ExpressionSyntax condition = null!;
        for (var i = binaryExpressions.Count - 1; i >= 0; i--) {
            condition = condition is null
                ? binaryExpressions[i]
                : BinaryExpression(
                    SyntaxKind.LogicalAndExpression,
                    binaryExpressions[i].WithTrailingTrivia(Space),
                    condition.WithLeadingTrivia(Space)
                );
        }

        return ConditionalExpression(
            condition.WithTrailingTrivia(Space),
            memberExpr.WithLeadingTrivia(Space).WithTrailingTrivia(Space),
            (nullFallback ?? LiteralExpression(SyntaxKind.NullLiteralExpression))
            .WithLeadingTrivia(Space)
        );
    }

    private static SwitchSectionSyntax CreateDefaultSwitchThrow(string sourceVarName, string indentation)
        => SwitchSection()
        .WithLabels(SingletonList<SwitchLabelSyntax>(
            DefaultSwitchLabel()
                .WithLeadingTrivia(Whitespace(indentation))
                .WithTrailingTrivia(CarriageReturnLineFeed)))
        .WithStatements(SingletonList<StatementSyntax>(
            ThrowStatement(
                ObjectCreationExpression(
                    //IdentifierName(nameof(MappingException))) // TODO: This currently does not work in consuming project. Need to investigate why
                    IdentifierName("MappingException")
                        .WithLeadingTrivia(Space))
                .WithLeadingTrivia(Space)
                .WithArgumentList(
                    ArgumentList(
                        SingletonSeparatedList(
                            Argument(
                                InterpolatedStringExpression(
                                        Token(SyntaxKind.InterpolatedStringStartToken))
                                .WithContents(List(new InterpolatedStringContentSyntax[] {
                                InterpolatedStringText()
                                .WithTextToken(Token(
                                    TriviaList(),
                                    SyntaxKind.InterpolatedStringTextToken,
                                    "Mapping from ",
                                    "Mapping from ",
                                    TriviaList())),
                                Interpolation(MemberAccessExpression(
                                    SyntaxKind.SimpleMemberAccessExpression,
                                    InvocationExpression(
                                        MemberAccessExpression(
                                            SyntaxKind.SimpleMemberAccessExpression,
                                            IdentifierName(sourceVarName),
                                            IdentifierName("GetType"))),
                                    IdentifierName("Name"))),
                                InterpolatedStringText()
                                .WithTextToken(Token(
                                    TriviaList(),
                                    SyntaxKind.InterpolatedStringTextToken,
                                    " to ",
                                    " to ",
                                    TriviaList())),
                                Interpolation(
                                    MemberAccessExpression(
                                        SyntaxKind.SimpleMemberAccessExpression,
                                        TypeOfExpression(
                                            IdentifierName(GENERIC_TYPE_NAME_DESTINATION)),
                                        IdentifierName("Name"))),
                                InterpolatedStringText()
                                .WithTextToken(Token(
                                    TriviaList(),
                                    SyntaxKind.InterpolatedStringTextToken,
                                    " has not been configured.",
                                    " has not been configured.",
                                    TriviaList()))
                                })))))))
            .WithLeadingTrivia(Whitespace(indentation + INDENT))));

    private static TypeDeclarationSyntax WithAutoGeneratedCodeAttributes(this TypeDeclarationSyntax interfaceDeclaration, string indentation, bool withCodeCoverageExclusion = false) {
        var attributes = new List<AttributeListSyntax> {
            // Generated-Code Attribute
            AttributeList(SingletonSeparatedList(
                Attribute(
                    AliasQualifiedName(
                        IdentifierName(Token(SyntaxKind.GlobalKeyword)),
                        FullAttributeDisplayIdentifier<System.CodeDom.Compiler.GeneratedCodeAttribute>()
                    )
                )
                .WithArgumentList(
                    AttributeArgumentList(SeparatedList<AttributeArgumentSyntax>(new SyntaxNodeOrToken[] {
                        AttributeArgument(
                            LiteralExpression(
                                SyntaxKind.StringLiteralExpression,
                                Literal(typeof(MapperGenerator).FullName))),
                        Token(
                            TriviaList(),
                            SyntaxKind.CommaToken,
                            TriviaList(Space)),
                        AttributeArgument(
                            LiteralExpression(
                                SyntaxKind.StringLiteralExpression,
                                Literal(_generatorVersion)))
                    })))))
            .WithLeadingTrivia(Whitespace(indentation))
            .WithTrailingTrivia(CarriageReturnLineFeed)
        };
        if (withCodeCoverageExclusion) {
            attributes.Add(
                // ExcludeFromCodeCoverage attribute
                AttributeList(SingletonSeparatedList(
                    Attribute(
                        AliasQualifiedName(
                            IdentifierName(Token(SyntaxKind.GlobalKeyword)),
                            FullAttributeDisplayIdentifier<System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverageAttribute>()
                        )
                    )))
                .WithLeadingTrivia(Whitespace(indentation))
                .WithTrailingTrivia(CarriageReturnLineFeed)
            );
        }

        return interfaceDeclaration.WithAttributeLists(List(attributes));
    }

    private static IdentifierNameSyntax FullAttributeDisplayIdentifier<TAttribute>() where TAttribute : Attribute {
        var attrName = typeof(TAttribute).FullName;
        var attrSuffix = "Attribute";
        return IdentifierName(attrName.Substring(0, attrName.Length - attrSuffix.Length));
    }
}
