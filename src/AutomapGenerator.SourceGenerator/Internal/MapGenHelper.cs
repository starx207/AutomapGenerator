using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;

namespace AutomapGenerator.SourceGenerator.Internal;

internal static class MapGenHelper {
    private const string INDENT = "    ";
    private const string MAP_METHOD_NAME = "Map";
    private const string PROJECTTO_METHOD_NAME = "ProjectTo";
    private const string GENERIC_TYPE_NAME_DESTINATION = "TDestination";
    private const string MAPPER_INTERFACE = "IMapper";
    private static readonly string _generatorVersion = typeof(MapperGenerator).Assembly.GetName().Version.ToString();

    public static NamespaceDeclarationSyntax CreateMapperClass(MapDefinition[] sources) {
        var mapperMethods = new List<MemberDeclarationSyntax> {
            CreateMapNewMethod(INDENT + INDENT), //.WithTrailingTrivia(CarriageReturnLineFeed, CarriageReturnLineFeed),
            CreateMapExistingMethod(INDENT + INDENT, sources).WithTrailingTrivia(CarriageReturnLineFeed, CarriageReturnLineFeed),
            CreateProjectToMethod(INDENT + INDENT, sources)
        };

        return CreateCoreNamespace()
        .WithMembers(
            SingletonList<MemberDeclarationSyntax>(
                //ClassDeclaration("Mapper")
                ClassDeclaration(Identifier(
                    TriviaList(Space),
                    "Mapper",
                    TriviaList(Space)))
                .WithAutoGeneratedCodeAttributes(INDENT, withCodeCoverageExclusion: true)
                .WithModifiers(
                    TokenList(Token(
                        TriviaList(Whitespace(INDENT)),
                        SyntaxKind.PublicKeyword,
                        TriviaList(Space))))
                .WithBaseList(
                    BaseList(
                        SingletonSeparatedList<BaseTypeSyntax>(
                            SimpleBaseType(IdentifierName(MAPPER_INTERFACE))
                                .WithLeadingTrivia(Space))))
                .WithOpenBraceToken(Token(
                    TriviaList(CarriageReturnLineFeed, Whitespace(INDENT)),
                    SyntaxKind.OpenBraceToken,
                    TriviaList(CarriageReturnLineFeed)))
                .WithCloseBraceToken(Token(
                    TriviaList(CarriageReturnLineFeed, Whitespace(INDENT)),
                    SyntaxKind.CloseBraceToken,
                    TriviaList()))
                .WithMembers(List(mapperMethods))));
    }

    private static MethodDeclarationSyntax CreateMapNewSignature(string sourceParamName, string indentation)
        => MethodDeclaration(
            IdentifierName(GENERIC_TYPE_NAME_DESTINATION),
            Identifier(TriviaList(Space), MAP_METHOD_NAME, TriviaList()))
        .WithTypeParameterList(
            TypeParameterList(
                SingletonSeparatedList(
                    TypeParameter(Identifier(GENERIC_TYPE_NAME_DESTINATION)))))
        .WithParameterList(
            ParameterList(
                SingletonSeparatedList(
                    Parameter(
                        Identifier(sourceParamName))
                    .WithType(PredefinedType(Token(
                        TriviaList(),
                        SyntaxKind.ObjectKeyword,
                        TriviaList(Space))))))
            .WithTrailingTrivia(CarriageReturnLineFeed))
        .WithConstraintClauses(
            SingletonList(
                TypeParameterConstraintClause(
                    Token(
                        TriviaList(Whitespace(indentation + INDENT)),
                        SyntaxKind.WhereKeyword,
                        TriviaList(Space)),
                    IdentifierName(GENERIC_TYPE_NAME_DESTINATION),
                    Token(
                        TriviaList(Space),
                        SyntaxKind.ColonToken,
                        TriviaList(Space)),
                    SingletonSeparatedList<TypeParameterConstraintSyntax>(
                        ConstructorConstraint()))));

    private static MethodDeclarationSyntax CreateMapExistingSignature(string sourceParamName, string destinationParamName)
        => MethodDeclaration(
            IdentifierName(GENERIC_TYPE_NAME_DESTINATION),
            Identifier(
                TriviaList(Space),
                MAP_METHOD_NAME,
                TriviaList()))
        .WithTypeParameterList(
            TypeParameterList(
                SingletonSeparatedList(
                    TypeParameter(
                        Identifier(GENERIC_TYPE_NAME_DESTINATION)))))
        .WithParameterList(
            ParameterList(
                SeparatedList<ParameterSyntax>(new SyntaxNodeOrToken[] {
                    Parameter(Identifier(TriviaList(Space), sourceParamName, TriviaList())).WithType(PredefinedType(Token(SyntaxKind.ObjectKeyword))),
                    Token(TriviaList(), SyntaxKind.CommaToken, TriviaList(Space)),
                    Parameter(Identifier(TriviaList(Space), destinationParamName, TriviaList())).WithType(IdentifierName(GENERIC_TYPE_NAME_DESTINATION))
                })));

    private static MethodDeclarationSyntax CreateProjectToSignature(string sourceParamName, string indentation)
        => MethodDeclaration(
                AliasQualifiedName(
                    IdentifierName(Token(SyntaxKind.GlobalKeyword)),
                    GenericName(Identifier(typeof(IQueryable).FullName))
                    .WithTypeArgumentList(TypeArgumentList(
                        SingletonSeparatedList<TypeSyntax>(IdentifierName(GENERIC_TYPE_NAME_DESTINATION))
                    ))
                    .WithTrailingTrivia(Space)
                ),
                Identifier(PROJECTTO_METHOD_NAME))
        .WithTypeParameterList(TypeParameterList(
            SingletonSeparatedList(
                TypeParameter(Identifier(GENERIC_TYPE_NAME_DESTINATION))
            )))
        .WithParameterList(ParameterList(
            SingletonSeparatedList(
                Parameter(Identifier(
                    TriviaList(Space),
                    sourceParamName,
                    TriviaList()))
                .WithType(
                    AliasQualifiedName(
                        IdentifierName(Token(SyntaxKind.GlobalKeyword)),
                        GenericName(Identifier(typeof(IQueryable).FullName))
                        .WithTypeArgumentList(TypeArgumentList(
                            SingletonSeparatedList<TypeSyntax>(PredefinedType(Token(SyntaxKind.ObjectKeyword)))
                        ))
                    ))
            )))
        .WithConstraintClauses(SingletonList(
            TypeParameterConstraintClause(
                IdentifierName(GENERIC_TYPE_NAME_DESTINATION)
                .WithLeadingTrivia(Space)
                .WithTrailingTrivia(Space))
            .WithConstraints(SingletonSeparatedList<TypeParameterConstraintSyntax>(
                ConstructorConstraint()
                .WithLeadingTrivia(Space)))
            .WithLeadingTrivia(CarriageReturnLineFeed, Whitespace(indentation + INDENT))
        ));

    private static NamespaceDeclarationSyntax CreateCoreNamespace()
        => NamespaceDeclaration(
            //IdentifierName(typeof(MappingException).Namespace)) // TODO: This currently does not work in consuming project. Need to investigate why
            IdentifierName("AutomapGenerator"))
        .WithNamespaceKeyword(
            Token(
                TriviaList(Comment("// <auto-generated/>"), CarriageReturnLineFeed),
                SyntaxKind.NamespaceKeyword,
                TriviaList(Space)))
        .WithOpenBraceToken(
            Token(
                TriviaList(CarriageReturnLineFeed),
                SyntaxKind.OpenBraceToken,
                TriviaList(CarriageReturnLineFeed)))
        .WithCloseBraceToken(
            Token(
                TriviaList(CarriageReturnLineFeed),
                SyntaxKind.CloseBraceToken,
                TriviaList(CarriageReturnLineFeed)));

    private static MethodDeclarationSyntax CreateMapNewMethod(string indentation) {
        var sourceVarName = "source";

        return CreateMapNewSignature(sourceVarName, indentation)
            .WithModifiers(
                TokenList(Token(
                    TriviaList(Whitespace(indentation)),
                    SyntaxKind.PublicKeyword,
                    TriviaList(Space))))
            .WithExpressionBody(
                ArrowExpressionClause(
                    InvocationExpression(
                        GenericName(
                            Identifier(MAP_METHOD_NAME))
                        .WithTypeArgumentList(
                            TypeArgumentList(
                                SingletonSeparatedList<TypeSyntax>(IdentifierName(GENERIC_TYPE_NAME_DESTINATION)))))
                    .WithLeadingTrivia(Space)
                    .WithArgumentList(
                        ArgumentList(
                            SeparatedList<ArgumentSyntax>(new SyntaxNodeOrToken[] {
                                Argument(IdentifierName(sourceVarName)),
                                Token(
                                    TriviaList(),
                                    SyntaxKind.CommaToken,
                                    TriviaList(Space)),
                                Argument(
                                    ObjectCreationExpression(IdentifierName(GENERIC_TYPE_NAME_DESTINATION).WithLeadingTrivia(Space))
                                    .WithArgumentList(ArgumentList()))
                            }))))
                .WithLeadingTrivia(Space))
            .WithSemicolonToken(Token(
                TriviaList(),
                SyntaxKind.SemicolonToken,
                TriviaList(CarriageReturnLineFeed)));
    }

    private static MethodDeclarationSyntax CreateMapExistingMethod(string indentation, MapDefinition[] srcMappings) {
        var destinationVarName = "destination";
        var sourceVarName = "source";

        var switchSections = new List<SwitchSectionSyntax>();
        for (var i = 0; i < srcMappings.Length; i++) {
            var definition = srcMappings[i];
            for (var j = 0; j < definition.Mappings.Count; j++) {
                var mapping = definition.Mappings[j];
                if (!mapping.ProjectionOnly) {
                    switchSections.Add(CreateMapMethodSwitchSection(definition, mapping, indentation + INDENT + INDENT));
                }
            }
        }

        // Add the default switch section 
        switchSections.Add(CreateDefaultSwitchThrow(sourceVarName, indentation + INDENT + INDENT));

        return CreateMapExistingSignature(sourceVarName, destinationVarName)
            .WithModifiers(
                TokenList(
                    Token(
                        TriviaList(Whitespace(indentation)),
                        SyntaxKind.PublicKeyword,
                        TriviaList(Space))))
            .WithBody(
                Block(
                    SwitchStatement(
                        TupleExpression(
                            SeparatedList<ArgumentSyntax>(new SyntaxNodeOrToken[] {
                                Argument(IdentifierName(sourceVarName)),
                                Token(TriviaList(), SyntaxKind.CommaToken, TriviaList(Space)),
                                Argument(IdentifierName(destinationVarName))
                            }))
                        .WithLeadingTrivia(Space))
                    .WithLeadingTrivia(Whitespace(indentation + INDENT))
                    .WithOpenBraceToken(Token(
                        TriviaList(CarriageReturnLineFeed, Whitespace(indentation + INDENT)),
                        SyntaxKind.OpenBraceToken,
                        TriviaList(CarriageReturnLineFeed)))
                    .WithSections(List(switchSections))
                    .WithCloseBraceToken(Token(
                        TriviaList(CarriageReturnLineFeed, Whitespace(indentation + INDENT)),
                        SyntaxKind.CloseBraceToken,
                        TriviaList(CarriageReturnLineFeed))),
                    ReturnStatement(IdentifierName(destinationVarName).WithLeadingTrivia(Space))
                        .WithLeadingTrivia(CarriageReturnLineFeed, Whitespace(indentation + INDENT))
                )
                .WithOpenBraceToken(Token(
                    TriviaList(CarriageReturnLineFeed, Whitespace(indentation)),
                    SyntaxKind.OpenBraceToken,
                    TriviaList(CarriageReturnLineFeed)))
                .WithCloseBraceToken(Token(
                    TriviaList(CarriageReturnLineFeed, Whitespace(indentation)),
                    SyntaxKind.CloseBraceToken,
                    TriviaList())));
    }

    private static MemberDeclarationSyntax CreateProjectToMethod(string indentation, MapDefinition[] srcMappings) {
        var destinationVarName = "destInstance";
        var sourceVarName = "source";

        var switchSections = new List<SwitchSectionSyntax>();
        for (var i = 0; i < srcMappings.Length; i++) {
            var definition = srcMappings[i];
            for (var j = 0; j < definition.Mappings.Count; j++) {
                var mapping = definition.Mappings[j];
                switchSections.Add(CreateProjectToMethodSwitchSection(definition, mapping, indentation + INDENT + INDENT));
            }
        }

        // Add the default switch section
        switchSections.Add(CreateDefaultSwitchThrow(sourceVarName, indentation + INDENT + INDENT));

        return CreateProjectToSignature(sourceVarName, indentation)
            .WithModifiers(
                TokenList(Token(
                    TriviaList(Whitespace(indentation)),
                    SyntaxKind.PublicKeyword,
                    TriviaList(Space))))
            .WithBody(
                Block(
                    LocalDeclarationStatement(
                        VariableDeclaration(
                            IdentifierName(
                                Identifier(
                                    TriviaList(),
                                    SyntaxKind.VarKeyword,
                                    "var",
                                    "var",
                                    TriviaList(Space))))
                        .WithVariables(
                            SingletonSeparatedList(
                                VariableDeclarator(
                                    Identifier(destinationVarName)
                                    .WithTrailingTrivia(Space))
                                .WithInitializer(
                                    EqualsValueClause(
                                        ObjectCreationExpression(
                                            IdentifierName(GENERIC_TYPE_NAME_DESTINATION)
                                            .WithLeadingTrivia(Space))
                                        .WithLeadingTrivia(Space)
                                        .WithArgumentList(ArgumentList()))))))
                    .WithLeadingTrivia(Whitespace(indentation + INDENT))
                    .WithTrailingTrivia(CarriageReturnLineFeed),

                    SwitchStatement(
                        TupleExpression(
                            SeparatedList<ArgumentSyntax>(new SyntaxNodeOrToken[] {
                                Argument(IdentifierName(sourceVarName)),
                                Token(TriviaList(), SyntaxKind.CommaToken, TriviaList(Space)),
                                Argument(IdentifierName(destinationVarName))
                            }))
                        .WithLeadingTrivia(Space))
                    .WithLeadingTrivia(Whitespace(indentation + INDENT))
                    .WithOpenBraceToken(Token(
                        TriviaList(CarriageReturnLineFeed, Whitespace(indentation + INDENT)),
                        SyntaxKind.OpenBraceToken,
                        TriviaList(CarriageReturnLineFeed)))
                    .WithSections(List(switchSections))
                    .WithCloseBraceToken(Token(
                        TriviaList(CarriageReturnLineFeed, Whitespace(indentation + INDENT)),
                        SyntaxKind.CloseBraceToken,
                        TriviaList()))
                )
                .WithOpenBraceToken(Token(
                    TriviaList(CarriageReturnLineFeed, Whitespace(indentation)),
                    SyntaxKind.OpenBraceToken,
                    TriviaList(CarriageReturnLineFeed)))
                .WithCloseBraceToken(Token(
                    TriviaList(CarriageReturnLineFeed, Whitespace(indentation)),
                    SyntaxKind.CloseBraceToken,
                    TriviaList())));
    }

    private static SwitchSectionSyntax CreateMapMethodSwitchSection(MapDefinition definition, MapDefinition.Mapping mapping, string indentation) {
        var patternMatchSrcName = ParseTypeName(mapping.SourceName);
        var patternMatchDestName = ParseTypeName(mapping.DestinationName);
        var matchedSrcVarName = "s";
        var matchedDestVarName = "d";

        var expressions = new List<StatementSyntax>();
        var destMappings = definition.GetDestinationMappings(mapping);
        for (var i = 0; i < destMappings.Count; i++) {
            (var destProp, var srcProp) = destMappings[i];

            expressions.Add(ExpressionStatement(
                AssignmentExpression(
                    SyntaxKind.SimpleAssignmentExpression,
                    MemberAccessExpression(
                        SyntaxKind.SimpleMemberAccessExpression,
                        IdentifierName(matchedDestVarName),
                        IdentifierName(destProp).WithTrailingTrivia(Space)),
                    MemberAccessExpression(
                        SyntaxKind.SimpleMemberAccessExpression,
                        IdentifierName(matchedSrcVarName).WithLeadingTrivia(Space),
                        IdentifierName(srcProp))))
                .WithLeadingTrivia(Whitespace(indentation + INDENT))
                .WithTrailingTrivia(CarriageReturnLineFeed));
        }
        expressions.Add(BreakStatement()
            .WithLeadingTrivia(Whitespace(indentation + INDENT))
            .WithTrailingTrivia(CarriageReturnLineFeed));

        return SwitchSection()
            .WithLabels(
                SingletonList<SwitchLabelSyntax>(
                    CasePatternSwitchLabel(
                        RecursivePattern()
                        .WithPositionalPatternClause(
                            PositionalPatternClause(
                                SeparatedList<SubpatternSyntax>(new SyntaxNodeOrToken[] {
                                    Subpattern(
                                        DeclarationPattern(
                                            patternMatchSrcName,
                                            SingleVariableDesignation(Identifier(
                                                TriviaList(Space),
                                                matchedSrcVarName,
                                                TriviaList())))),
                                    Token(
                                        TriviaList(),
                                        SyntaxKind.CommaToken,
                                        TriviaList(Space)),
                                    Subpattern(
                                        DeclarationPattern(
                                            patternMatchDestName,
                                            SingleVariableDesignation(Identifier(
                                                TriviaList(Space),
                                                matchedDestVarName,
                                                TriviaList()))))
                                }))
                            .WithLeadingTrivia(Space)),
                        Token(SyntaxKind.ColonToken))))
            .WithLeadingTrivia(Whitespace(indentation))
            .WithTrailingTrivia(CarriageReturn)
            .WithStatements(List(expressions));
    }

    private static SwitchSectionSyntax CreateProjectToMethodSwitchSection(MapDefinition definition, MapDefinition.Mapping mapping, string indentation) {
        var patternMatchSrcName = ParseTypeName(mapping.SourceName);
        var patternMatchDestName = ParseTypeName(mapping.DestinationName);
        var matchedSrcVarName = "s";
        var lambdaVarName = "src";

        var expressions = new List<SyntaxNodeOrToken>();
        var destMappings = definition.GetDestinationMappings(mapping);
        for (var i = 0; i < destMappings.Count; i++) {
            (var destProp, var srcProp) = destMappings[i];

            // Add a comma after the last expression before adding another
            if (expressions.Count > 0) {
                expressions.Add(Token(
                    TriviaList(),
                    SyntaxKind.CommaToken,
                    TriviaList(Space)));
            }

            var nullableParts = srcProp.Split(new[] { "?." }, StringSplitOptions.None);
            ExpressionSyntax expressionRight;

            expressionRight = MemberAccessExpression(
                SyntaxKind.SimpleMemberAccessExpression,
                IdentifierName(lambdaVarName),
                IdentifierName(string.Join(".", nullableParts))
            );
            if (nullableParts.Length > 1) {
                var binaryExpressions = new List<ExpressionSyntax>();

                // Do not consume the last nullable part as it is the final value
                // TODO: We do need to test it if a null fallback has been defined
                var nullCheckIdentifier = string.Empty;
                for (var j = 0; j < nullableParts.Length - 1; j++) {
                    if (nullCheckIdentifier.Length > 0) {
                        nullCheckIdentifier += ".";
                    }
                    nullCheckIdentifier += nullableParts[j];

                    binaryExpressions.Add(BinaryExpression(
                        SyntaxKind.NotEqualsExpression,
                        MemberAccessExpression(
                            SyntaxKind.SimpleMemberAccessExpression,
                            IdentifierName(lambdaVarName),
                            IdentifierName(nullCheckIdentifier)
                        ).WithTrailingTrivia(Space),
                        LiteralExpression(SyntaxKind.NullLiteralExpression)
                        .WithLeadingTrivia(Space)
                    ));
                }

                // Process the binary expressions in the reverse order in order to build them up correctly
                ExpressionSyntax condition = null!;
                for (var j = binaryExpressions.Count - 1; j >= 0; j--) {
                    condition = condition is null
                        ? binaryExpressions[j]
                        : BinaryExpression(
                            SyntaxKind.LogicalAndExpression,
                            binaryExpressions[j].WithTrailingTrivia(Space),
                            condition.WithLeadingTrivia(Space)
                        );
                }

                expressionRight = ConditionalExpression(
                    condition.WithTrailingTrivia(Space),
                    expressionRight.WithLeadingTrivia(Space).WithTrailingTrivia(Space),
                    LiteralExpression(SyntaxKind.NullLiteralExpression)
                    .WithLeadingTrivia(Space)
                );
            }

            expressions.Add(
                AssignmentExpression(
                    SyntaxKind.SimpleAssignmentExpression,
                    IdentifierName(destProp).WithTrailingTrivia(Space),
                    expressionRight.WithLeadingTrivia(Space)));
        }

        var objectInitializerExpression = ObjectCreationExpression(patternMatchDestName)
            .WithNewKeyword(Token(
                TriviaList(Space),
                SyntaxKind.NewKeyword,
                TriviaList(Space)))
            .WithArgumentList(ArgumentList());

        if (expressions.Count > 0) {
            objectInitializerExpression = objectInitializerExpression
                .WithInitializer(
                    InitializerExpression(
                        SyntaxKind.ObjectInitializerExpression,
                        SeparatedList<ExpressionSyntax>(expressions))
                    .WithOpenBraceToken(Token(
                        TriviaList(Space),
                        SyntaxKind.OpenBraceToken,
                        TriviaList(Space)))
                    .WithCloseBraceToken(Token(
                        TriviaList(Space),
                        SyntaxKind.CloseBraceToken,
                        TriviaList())));
        }

        return SwitchSection()
            .WithLabels(
                SingletonList<SwitchLabelSyntax>(
                    CasePatternSwitchLabel(
                        RecursivePattern()
                        .WithPositionalPatternClause(
                            PositionalPatternClause(
                                SeparatedList<SubpatternSyntax>(new SyntaxNodeOrToken[] {
                                    Subpattern(
                                        DeclarationPattern(
                                            AliasQualifiedName(
                                                IdentifierName(Token(SyntaxKind.GlobalKeyword)),
                                                GenericName(Identifier(typeof(IQueryable).FullName))
                                                .WithTypeArgumentList(
                                                    TypeArgumentList(SingletonSeparatedList(patternMatchSrcName)))
                                            ),
                                            SingleVariableDesignation(Identifier(
                                                TriviaList(Space),
                                                matchedSrcVarName,
                                                TriviaList()))
                                        )),
                                    Token(
                                        TriviaList(),
                                        SyntaxKind.CommaToken,
                                        TriviaList(Space)),
                                    Subpattern(
                                        ConstantPattern(ParseExpression(mapping.DestinationName)))
                                })))
                        .WithLeadingTrivia(Space),
                        Token(SyntaxKind.ColonToken))
                    .WithLeadingTrivia(Whitespace(indentation))
                    .WithTrailingTrivia(CarriageReturnLineFeed)))
            .WithStatements(
                SingletonList<StatementSyntax>(
                    ReturnStatement(
                        InvocationExpression(
                            MemberAccessExpression(
                                SyntaxKind.SimpleMemberAccessExpression,
                                MemberAccessExpression(
                                    SyntaxKind.SimpleMemberAccessExpression,
                                    AliasQualifiedName(
                                        IdentifierName(Token(SyntaxKind.GlobalKeyword)),
                                        IdentifierName(typeof(Queryable).Namespace)
                                    ),
                                    IdentifierName(nameof(Queryable))),
                                GenericName(Identifier(nameof(Queryable.Cast)))
                                .WithTypeArgumentList(
                                    TypeArgumentList(
                                        SingletonSeparatedList<TypeSyntax>(IdentifierName(GENERIC_TYPE_NAME_DESTINATION))))))
                        .WithLeadingTrivia(Space)
                        .WithArgumentList(
                            ArgumentList(
                                SingletonSeparatedList(
                                    Argument(
                                        InvocationExpression(
                                            MemberAccessExpression(
                                                SyntaxKind.SimpleMemberAccessExpression,
                                                MemberAccessExpression(
                                                    SyntaxKind.SimpleMemberAccessExpression,
                                                    AliasQualifiedName(
                                                        IdentifierName(Token(SyntaxKind.GlobalKeyword)),
                                                        IdentifierName(typeof(Queryable).Namespace)),
                                                    IdentifierName(nameof(Queryable))),
                                                IdentifierName(nameof(Queryable.Select))))
                                        .WithArgumentList(
                                            ArgumentList(
                                                SeparatedList<ArgumentSyntax>(new SyntaxNodeOrToken[] {
                                                    Argument(IdentifierName(matchedSrcVarName)),
                                                    Token(
                                                        TriviaList(),
                                                        SyntaxKind.CommaToken,
                                                        TriviaList(Space)),
                                                    Argument(SimpleLambdaExpression(
                                                        Parameter(Identifier(
                                                            TriviaList(),
                                                            lambdaVarName,
                                                            TriviaList(Space))))
                                                    .WithExpressionBody(objectInitializerExpression))
                                                }))))))))
                    .WithLeadingTrivia(Whitespace(indentation + INDENT))
                    .WithTrailingTrivia(CarriageReturnLineFeed)));
    }

    private static SwitchSectionSyntax CreateDefaultSwitchThrow(string sourceVarName, string indentation)
        => SwitchSection()
        .WithLabels(SingletonList<SwitchLabelSyntax>(
            DefaultSwitchLabel()
                .WithLeadingTrivia(Whitespace(indentation))
                .WithTrailingTrivia(CarriageReturnLineFeed)))
        .WithStatements(SingletonList<StatementSyntax>(
            ThrowStatement(
                ObjectCreationExpression(
                    //IdentifierName(nameof(MappingException))) // TODO: This currently does not work in consuming project. Need to investigate why
                    IdentifierName("MappingException")
                        .WithLeadingTrivia(Space))
                .WithLeadingTrivia(Space)
                .WithArgumentList(
                    ArgumentList(
                        SingletonSeparatedList(
                            Argument(
                                InterpolatedStringExpression(
                                        Token(SyntaxKind.InterpolatedStringStartToken))
                                .WithContents(List(new InterpolatedStringContentSyntax[] {
                                InterpolatedStringText()
                                .WithTextToken(Token(
                                    TriviaList(),
                                    SyntaxKind.InterpolatedStringTextToken,
                                    "Mapping from ",
                                    "Mapping from ",
                                    TriviaList())),
                                Interpolation(MemberAccessExpression(
                                    SyntaxKind.SimpleMemberAccessExpression,
                                    InvocationExpression(
                                        MemberAccessExpression(
                                            SyntaxKind.SimpleMemberAccessExpression,
                                            IdentifierName(sourceVarName),
                                            IdentifierName("GetType"))),
                                    IdentifierName("Name"))),
                                InterpolatedStringText()
                                .WithTextToken(Token(
                                    TriviaList(),
                                    SyntaxKind.InterpolatedStringTextToken,
                                    " to ",
                                    " to ",
                                    TriviaList())),
                                Interpolation(
                                    MemberAccessExpression(
                                        SyntaxKind.SimpleMemberAccessExpression,
                                        TypeOfExpression(
                                            IdentifierName(GENERIC_TYPE_NAME_DESTINATION)),
                                        IdentifierName("Name"))),
                                InterpolatedStringText()
                                .WithTextToken(Token(
                                    TriviaList(),
                                    SyntaxKind.InterpolatedStringTextToken,
                                    " has not been configured.",
                                    " has not been configured.",
                                    TriviaList()))
                                })))))))
            .WithLeadingTrivia(Whitespace(indentation + INDENT))));

    private static TypeDeclarationSyntax WithAutoGeneratedCodeAttributes(this TypeDeclarationSyntax interfaceDeclaration, string indentation, bool withCodeCoverageExclusion = false) {
        var attributes = new List<AttributeListSyntax> {
            // Generated-Code Attribute
            AttributeList(SingletonSeparatedList(
                Attribute(
                    AliasQualifiedName(
                        IdentifierName(Token(SyntaxKind.GlobalKeyword)),
                        FullAttributeDisplayIdentifier<System.CodeDom.Compiler.GeneratedCodeAttribute>()
                    )
                )
                .WithArgumentList(
                    AttributeArgumentList(SeparatedList<AttributeArgumentSyntax>(new SyntaxNodeOrToken[] {
                        AttributeArgument(
                            LiteralExpression(
                                SyntaxKind.StringLiteralExpression,
                                Literal(typeof(MapperGenerator).FullName))),
                        Token(
                            TriviaList(),
                            SyntaxKind.CommaToken,
                            TriviaList(Space)),
                        AttributeArgument(
                            LiteralExpression(
                                SyntaxKind.StringLiteralExpression,
                                Literal(_generatorVersion)))
                    })))))
            .WithLeadingTrivia(Whitespace(indentation))
            .WithTrailingTrivia(CarriageReturnLineFeed)
        };
        if (withCodeCoverageExclusion) {
            attributes.Add(
                // ExcludeFromCodeCoverage attribute
                AttributeList(SingletonSeparatedList(
                    Attribute(
                        AliasQualifiedName(
                            IdentifierName(Token(SyntaxKind.GlobalKeyword)),
                            FullAttributeDisplayIdentifier<System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverageAttribute>()
                        )
                    )))
                .WithLeadingTrivia(Whitespace(indentation))
                .WithTrailingTrivia(CarriageReturnLineFeed)
            );
        }

        return interfaceDeclaration.WithAttributeLists(List(attributes));
    }

    private static IdentifierNameSyntax FullAttributeDisplayIdentifier<TAttribute>() where TAttribute : Attribute {
        var attrName = typeof(TAttribute).FullName;
        var attrSuffix = "Attribute";
        return IdentifierName(attrName.Substring(0, attrName.Length - attrSuffix.Length));
    }
}
